#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Sep 30 11:10:31 2019 by generateDS.py version 2.33.6.
# Python 3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:59:51) [MSC v.1914 64 bit (AMD64)]
#
# Command line options:
#   ('-o', 'mySWC_api.py')
#
# Command line arguments:
#   mySWC.xsd
#
# Command line:
#   generateDS.py -o "mySWC_api.py" mySWC.xsd
#
# Current working directory (os.getcwd()):
#   generateDS-2.33.6
#

import os
import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
import decimal as decimal_
import pandas as pd
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_



Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'requires integer: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'requires float or double: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires sequence of floats')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return ('%0.10f' % input_data).rstrip('0')
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'requires float or double: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'requires boolean')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class DATA_ELEMENT_REF(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DEST=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DEST = _cast(None, DEST)
        self.DEST_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATA_ELEMENT_REF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATA_ELEMENT_REF.subclass:
            return DATA_ELEMENT_REF.subclass(*args_, **kwargs_)
        else:
            return DATA_ELEMENT_REF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DEST(self):
        return self.DEST
    def set_DEST(self, DEST):
        self.DEST = DEST
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='DATA-ELEMENT-REF', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATA-ELEMENT-REF')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATA-ELEMENT-REF')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATA-ELEMENT-REF', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATA-ELEMENT-REF'):
        if self.DEST is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            outfile.write(' DEST=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DEST), input_name='DEST')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='DATA-ELEMENT-REF', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DEST', node)
        if value is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            self.DEST = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DATA_ELEMENT_REF


class INIT_VALUE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NUMERICAL_VALUE_SPECIFICATION=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if NUMERICAL_VALUE_SPECIFICATION is None:
            self.NUMERICAL_VALUE_SPECIFICATION = []
        else:
            self.NUMERICAL_VALUE_SPECIFICATION = NUMERICAL_VALUE_SPECIFICATION
        self.NUMERICAL_VALUE_SPECIFICATION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INIT_VALUE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INIT_VALUE.subclass:
            return INIT_VALUE.subclass(*args_, **kwargs_)
        else:
            return INIT_VALUE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NUMERICAL_VALUE_SPECIFICATION(self):
        return self.NUMERICAL_VALUE_SPECIFICATION
    def set_NUMERICAL_VALUE_SPECIFICATION(self, NUMERICAL_VALUE_SPECIFICATION):
        self.NUMERICAL_VALUE_SPECIFICATION = NUMERICAL_VALUE_SPECIFICATION
    def add_NUMERICAL_VALUE_SPECIFICATION(self, value):
        self.NUMERICAL_VALUE_SPECIFICATION.append(value)
    def insert_NUMERICAL_VALUE_SPECIFICATION_at(self, index, value):
        self.NUMERICAL_VALUE_SPECIFICATION.insert(index, value)
    def replace_NUMERICAL_VALUE_SPECIFICATION_at(self, index, value):
        self.NUMERICAL_VALUE_SPECIFICATION[index] = value
    def hasContent_(self):
        if (
            self.NUMERICAL_VALUE_SPECIFICATION
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='INIT-VALUE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INIT-VALUE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='INIT-VALUE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='INIT-VALUE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='INIT-VALUE'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='INIT-VALUE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NUMERICAL_VALUE_SPECIFICATION_ in self.NUMERICAL_VALUE_SPECIFICATION:
            namespaceprefix_ = self.NUMERICAL_VALUE_SPECIFICATION_nsprefix_ + ':' if (UseCapturedNS_ and self.NUMERICAL_VALUE_SPECIFICATION_nsprefix_) else ''
            NUMERICAL_VALUE_SPECIFICATION_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NUMERICAL-VALUE-SPECIFICATION', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NUMERICAL-VALUE-SPECIFICATION':
            obj_ = NUMERICAL_VALUE_SPECIFICATIONType.factory(parent_object_=self)
            obj_.build(child_)
            self.NUMERICAL_VALUE_SPECIFICATION.append(obj_)
            obj_.original_tagname_ = 'NUMERICAL-VALUE-SPECIFICATION'
# end class INIT_VALUE


class START_ON_EVENT_REF(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DEST=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DEST = _cast(None, DEST)
        self.DEST_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, START_ON_EVENT_REF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if START_ON_EVENT_REF.subclass:
            return START_ON_EVENT_REF.subclass(*args_, **kwargs_)
        else:
            return START_ON_EVENT_REF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DEST(self):
        return self.DEST
    def set_DEST(self, DEST):
        self.DEST = DEST
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='START-ON-EVENT-REF', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('START-ON-EVENT-REF')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='START-ON-EVENT-REF')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='START-ON-EVENT-REF', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='START-ON-EVENT-REF'):
        if self.DEST is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            outfile.write(' DEST=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DEST), input_name='DEST')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='START-ON-EVENT-REF', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DEST', node)
        if value is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            self.DEST = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class START_ON_EVENT_REF


class VARIABLE_ACCESS(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UUID=None, SHORT_NAME=None, ACCESSED_VARIABLE=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.UUID = _cast(None, UUID)
        self.UUID_nsprefix_ = None
        self.SHORT_NAME = SHORT_NAME
        self.SHORT_NAME_nsprefix_ = None
        if ACCESSED_VARIABLE is None:
            self.ACCESSED_VARIABLE = []
        else:
            self.ACCESSED_VARIABLE = ACCESSED_VARIABLE
        self.ACCESSED_VARIABLE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VARIABLE_ACCESS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VARIABLE_ACCESS.subclass:
            return VARIABLE_ACCESS.subclass(*args_, **kwargs_)
        else:
            return VARIABLE_ACCESS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SHORT_NAME(self):
        return self.SHORT_NAME
    def set_SHORT_NAME(self, SHORT_NAME):
        self.SHORT_NAME = SHORT_NAME
    def get_ACCESSED_VARIABLE(self):
        return self.ACCESSED_VARIABLE
    def set_ACCESSED_VARIABLE(self, ACCESSED_VARIABLE):
        self.ACCESSED_VARIABLE = ACCESSED_VARIABLE
    def add_ACCESSED_VARIABLE(self, value):
        self.ACCESSED_VARIABLE.append(value)
    def insert_ACCESSED_VARIABLE_at(self, index, value):
        self.ACCESSED_VARIABLE.insert(index, value)
    def replace_ACCESSED_VARIABLE_at(self, index, value):
        self.ACCESSED_VARIABLE[index] = value
    def get_UUID(self):
        return self.UUID
    def set_UUID(self, UUID):
        self.UUID = UUID
    def hasContent_(self):
        if (
            self.SHORT_NAME is not None or
            self.ACCESSED_VARIABLE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='VARIABLE-ACCESS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VARIABLE-ACCESS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VARIABLE-ACCESS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VARIABLE-ACCESS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VARIABLE-ACCESS'):
        if self.UUID is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            outfile.write(' UUID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UUID), input_name='UUID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='VARIABLE-ACCESS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SHORT_NAME is not None:
            namespaceprefix_ = self.SHORT_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SHORT_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHORT-NAME>%s</%sSHORT-NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SHORT_NAME), input_name='SHORT-NAME')), namespaceprefix_ , eol_))
        for ACCESSED_VARIABLE_ in self.ACCESSED_VARIABLE:
            namespaceprefix_ = self.ACCESSED_VARIABLE_nsprefix_ + ':' if (UseCapturedNS_ and self.ACCESSED_VARIABLE_nsprefix_) else ''
            ACCESSED_VARIABLE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ACCESSED-VARIABLE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UUID', node)
        if value is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            self.UUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SHORT-NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SHORT_NAME')
            value_ = self.gds_validate_string(value_, node, 'SHORT_NAME')
            self.SHORT_NAME = value_
            self.SHORT_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'ACCESSED-VARIABLE':
            obj_ = ACCESSED_VARIABLEType.factory(parent_object_=self)
            obj_.build(child_)
            self.ACCESSED_VARIABLE.append(obj_)
            obj_.original_tagname_ = 'ACCESSED-VARIABLE'
# end class VARIABLE_ACCESS


class AUTOSAR(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATA_ELEMENT_REF=None, INIT_VALUE=None, START_ON_EVENT_REF=None, VARIABLE_ACCESS=None, AR_PACKAGES=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DATA_ELEMENT_REF is None:
            self.DATA_ELEMENT_REF = []
        else:
            self.DATA_ELEMENT_REF = DATA_ELEMENT_REF
        self.DATA_ELEMENT_REF_nsprefix_ = None
        if INIT_VALUE is None:
            self.INIT_VALUE = []
        else:
            self.INIT_VALUE = INIT_VALUE
        self.INIT_VALUE_nsprefix_ = None
        if START_ON_EVENT_REF is None:
            self.START_ON_EVENT_REF = []
        else:
            self.START_ON_EVENT_REF = START_ON_EVENT_REF
        self.START_ON_EVENT_REF_nsprefix_ = None
        if VARIABLE_ACCESS is None:
            self.VARIABLE_ACCESS = []
        else:
            self.VARIABLE_ACCESS = VARIABLE_ACCESS
        self.VARIABLE_ACCESS_nsprefix_ = None
        if AR_PACKAGES is None:
            self.AR_PACKAGES = []
        else:
            self.AR_PACKAGES = AR_PACKAGES
        self.AR_PACKAGES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AUTOSAR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AUTOSAR.subclass:
            return AUTOSAR.subclass(*args_, **kwargs_)
        else:
            return AUTOSAR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATA_ELEMENT_REF(self):
        return self.DATA_ELEMENT_REF
    def set_DATA_ELEMENT_REF(self, DATA_ELEMENT_REF):
        self.DATA_ELEMENT_REF = DATA_ELEMENT_REF
    def add_DATA_ELEMENT_REF(self, value):
        self.DATA_ELEMENT_REF.append(value)
    def insert_DATA_ELEMENT_REF_at(self, index, value):
        self.DATA_ELEMENT_REF.insert(index, value)
    def replace_DATA_ELEMENT_REF_at(self, index, value):
        self.DATA_ELEMENT_REF[index] = value
    def get_INIT_VALUE(self):
        return self.INIT_VALUE
    def set_INIT_VALUE(self, INIT_VALUE):
        self.INIT_VALUE = INIT_VALUE
    def add_INIT_VALUE(self, value):
        self.INIT_VALUE.append(value)
    def insert_INIT_VALUE_at(self, index, value):
        self.INIT_VALUE.insert(index, value)
    def replace_INIT_VALUE_at(self, index, value):
        self.INIT_VALUE[index] = value
    def get_START_ON_EVENT_REF(self):
        return self.START_ON_EVENT_REF
    def set_START_ON_EVENT_REF(self, START_ON_EVENT_REF):
        self.START_ON_EVENT_REF = START_ON_EVENT_REF
    def add_START_ON_EVENT_REF(self, value):
        self.START_ON_EVENT_REF.append(value)
    def insert_START_ON_EVENT_REF_at(self, index, value):
        self.START_ON_EVENT_REF.insert(index, value)
    def replace_START_ON_EVENT_REF_at(self, index, value):
        self.START_ON_EVENT_REF[index] = value
    def get_VARIABLE_ACCESS(self):
        return self.VARIABLE_ACCESS
    def set_VARIABLE_ACCESS(self, VARIABLE_ACCESS):
        self.VARIABLE_ACCESS = VARIABLE_ACCESS
    def add_VARIABLE_ACCESS(self, value):
        self.VARIABLE_ACCESS.append(value)
    def insert_VARIABLE_ACCESS_at(self, index, value):
        self.VARIABLE_ACCESS.insert(index, value)
    def replace_VARIABLE_ACCESS_at(self, index, value):
        self.VARIABLE_ACCESS[index] = value
    def get_AR_PACKAGES(self):
        return self.AR_PACKAGES
    def set_AR_PACKAGES(self, AR_PACKAGES):
        self.AR_PACKAGES = AR_PACKAGES
    def add_AR_PACKAGES(self, value):
        self.AR_PACKAGES.append(value)
    def insert_AR_PACKAGES_at(self, index, value):
        self.AR_PACKAGES.insert(index, value)
    def replace_AR_PACKAGES_at(self, index, value):
        self.AR_PACKAGES[index] = value
    def hasContent_(self):
        if (
            self.DATA_ELEMENT_REF or
            self.INIT_VALUE or
            self.START_ON_EVENT_REF or
            self.VARIABLE_ACCESS or
            self.AR_PACKAGES
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='AUTOSAR', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AUTOSAR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AUTOSAR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AUTOSAR', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AUTOSAR'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='AUTOSAR', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATA_ELEMENT_REF_ in self.DATA_ELEMENT_REF:
            namespaceprefix_ = self.DATA_ELEMENT_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.DATA_ELEMENT_REF_nsprefix_) else ''
            DATA_ELEMENT_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATA-ELEMENT-REF', pretty_print=pretty_print)
        for INIT_VALUE_ in self.INIT_VALUE:
            namespaceprefix_ = self.INIT_VALUE_nsprefix_ + ':' if (UseCapturedNS_ and self.INIT_VALUE_nsprefix_) else ''
            INIT_VALUE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='INIT-VALUE', pretty_print=pretty_print)
        for START_ON_EVENT_REF_ in self.START_ON_EVENT_REF:
            namespaceprefix_ = self.START_ON_EVENT_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.START_ON_EVENT_REF_nsprefix_) else ''
            START_ON_EVENT_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='START-ON-EVENT-REF', pretty_print=pretty_print)
        for VARIABLE_ACCESS_ in self.VARIABLE_ACCESS:
            namespaceprefix_ = self.VARIABLE_ACCESS_nsprefix_ + ':' if (UseCapturedNS_ and self.VARIABLE_ACCESS_nsprefix_) else ''
            VARIABLE_ACCESS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VARIABLE-ACCESS', pretty_print=pretty_print)
        for AR_PACKAGES_ in self.AR_PACKAGES:
            namespaceprefix_ = self.AR_PACKAGES_nsprefix_ + ':' if (UseCapturedNS_ and self.AR_PACKAGES_nsprefix_) else ''
            AR_PACKAGES_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AR-PACKAGES', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATA-ELEMENT-REF':
            obj_ = DATA_ELEMENT_REF.factory(parent_object_=self)
            obj_.build(child_)
            self.DATA_ELEMENT_REF.append(obj_)
            obj_.original_tagname_ = 'DATA-ELEMENT-REF'
        elif nodeName_ == 'INIT-VALUE':
            obj_ = INIT_VALUE.factory(parent_object_=self)
            obj_.build(child_)
            self.INIT_VALUE.append(obj_)
            obj_.original_tagname_ = 'INIT-VALUE'
        elif nodeName_ == 'START-ON-EVENT-REF':
            obj_ = START_ON_EVENT_REF.factory(parent_object_=self)
            obj_.build(child_)
            self.START_ON_EVENT_REF.append(obj_)
            obj_.original_tagname_ = 'START-ON-EVENT-REF'
        elif nodeName_ == 'VARIABLE-ACCESS':
            obj_ = VARIABLE_ACCESS.factory(parent_object_=self)
            obj_.build(child_)
            self.VARIABLE_ACCESS.append(obj_)
            obj_.original_tagname_ = 'VARIABLE-ACCESS'
        elif nodeName_ == 'AR-PACKAGES':
            obj_ = AR_PACKAGESType.factory(parent_object_=self)
            obj_.build(child_)
            self.AR_PACKAGES.append(obj_)
            obj_.original_tagname_ = 'AR-PACKAGES'
# end class AUTOSAR


class NUMERICAL_VALUE_SPECIFICATIONType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VALUE=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.VALUE = VALUE
        self.VALUE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NUMERICAL_VALUE_SPECIFICATIONType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NUMERICAL_VALUE_SPECIFICATIONType.subclass:
            return NUMERICAL_VALUE_SPECIFICATIONType.subclass(*args_, **kwargs_)
        else:
            return NUMERICAL_VALUE_SPECIFICATIONType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VALUE(self):
        return self.VALUE
    def set_VALUE(self, VALUE):
        self.VALUE = VALUE
    def hasContent_(self):
        if (
            self.VALUE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='NUMERICAL-VALUE-SPECIFICATIONType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NUMERICAL-VALUE-SPECIFICATIONType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NUMERICAL-VALUE-SPECIFICATIONType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NUMERICAL-VALUE-SPECIFICATIONType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NUMERICAL-VALUE-SPECIFICATIONType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='NUMERICAL-VALUE-SPECIFICATIONType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VALUE is not None:
            namespaceprefix_ = self.VALUE_nsprefix_ + ':' if (UseCapturedNS_ and self.VALUE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVALUE>%s</%sVALUE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VALUE), input_name='VALUE')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VALUE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VALUE')
            value_ = self.gds_validate_string(value_, node, 'VALUE')
            self.VALUE = value_
            self.VALUE_nsprefix_ = child_.prefix
# end class NUMERICAL_VALUE_SPECIFICATIONType


class ACCESSED_VARIABLEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, AUTOSAR_VARIABLE_IREF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if AUTOSAR_VARIABLE_IREF is None:
            self.AUTOSAR_VARIABLE_IREF = []
        else:
            self.AUTOSAR_VARIABLE_IREF = AUTOSAR_VARIABLE_IREF
        self.AUTOSAR_VARIABLE_IREF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACCESSED_VARIABLEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACCESSED_VARIABLEType.subclass:
            return ACCESSED_VARIABLEType.subclass(*args_, **kwargs_)
        else:
            return ACCESSED_VARIABLEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AUTOSAR_VARIABLE_IREF(self):
        return self.AUTOSAR_VARIABLE_IREF
    def set_AUTOSAR_VARIABLE_IREF(self, AUTOSAR_VARIABLE_IREF):
        self.AUTOSAR_VARIABLE_IREF = AUTOSAR_VARIABLE_IREF
    def add_AUTOSAR_VARIABLE_IREF(self, value):
        self.AUTOSAR_VARIABLE_IREF.append(value)
    def insert_AUTOSAR_VARIABLE_IREF_at(self, index, value):
        self.AUTOSAR_VARIABLE_IREF.insert(index, value)
    def replace_AUTOSAR_VARIABLE_IREF_at(self, index, value):
        self.AUTOSAR_VARIABLE_IREF[index] = value
    def hasContent_(self):
        if (
            self.AUTOSAR_VARIABLE_IREF
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='ACCESSED-VARIABLEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ACCESSED-VARIABLEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ACCESSED-VARIABLEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ACCESSED-VARIABLEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ACCESSED-VARIABLEType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='ACCESSED-VARIABLEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AUTOSAR_VARIABLE_IREF_ in self.AUTOSAR_VARIABLE_IREF:
            namespaceprefix_ = self.AUTOSAR_VARIABLE_IREF_nsprefix_ + ':' if (UseCapturedNS_ and self.AUTOSAR_VARIABLE_IREF_nsprefix_) else ''
            AUTOSAR_VARIABLE_IREF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AUTOSAR-VARIABLE-IREF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AUTOSAR-VARIABLE-IREF':
            obj_ = AUTOSAR_VARIABLE_IREFType.factory(parent_object_=self)
            obj_.build(child_)
            self.AUTOSAR_VARIABLE_IREF.append(obj_)
            obj_.original_tagname_ = 'AUTOSAR-VARIABLE-IREF'
# end class ACCESSED_VARIABLEType


class AUTOSAR_VARIABLE_IREFType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PORT_PROTOTYPE_REF=None, TARGET_DATA_PROTOTYPE_REF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if PORT_PROTOTYPE_REF is None:
            self.PORT_PROTOTYPE_REF = []
        else:
            self.PORT_PROTOTYPE_REF = PORT_PROTOTYPE_REF
        self.PORT_PROTOTYPE_REF_nsprefix_ = None
        if TARGET_DATA_PROTOTYPE_REF is None:
            self.TARGET_DATA_PROTOTYPE_REF = []
        else:
            self.TARGET_DATA_PROTOTYPE_REF = TARGET_DATA_PROTOTYPE_REF
        self.TARGET_DATA_PROTOTYPE_REF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AUTOSAR_VARIABLE_IREFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AUTOSAR_VARIABLE_IREFType.subclass:
            return AUTOSAR_VARIABLE_IREFType.subclass(*args_, **kwargs_)
        else:
            return AUTOSAR_VARIABLE_IREFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PORT_PROTOTYPE_REF(self):
        return self.PORT_PROTOTYPE_REF
    def set_PORT_PROTOTYPE_REF(self, PORT_PROTOTYPE_REF):
        self.PORT_PROTOTYPE_REF = PORT_PROTOTYPE_REF
    def add_PORT_PROTOTYPE_REF(self, value):
        self.PORT_PROTOTYPE_REF.append(value)
    def insert_PORT_PROTOTYPE_REF_at(self, index, value):
        self.PORT_PROTOTYPE_REF.insert(index, value)
    def replace_PORT_PROTOTYPE_REF_at(self, index, value):
        self.PORT_PROTOTYPE_REF[index] = value
    def get_TARGET_DATA_PROTOTYPE_REF(self):
        return self.TARGET_DATA_PROTOTYPE_REF
    def set_TARGET_DATA_PROTOTYPE_REF(self, TARGET_DATA_PROTOTYPE_REF):
        self.TARGET_DATA_PROTOTYPE_REF = TARGET_DATA_PROTOTYPE_REF
    def add_TARGET_DATA_PROTOTYPE_REF(self, value):
        self.TARGET_DATA_PROTOTYPE_REF.append(value)
    def insert_TARGET_DATA_PROTOTYPE_REF_at(self, index, value):
        self.TARGET_DATA_PROTOTYPE_REF.insert(index, value)
    def replace_TARGET_DATA_PROTOTYPE_REF_at(self, index, value):
        self.TARGET_DATA_PROTOTYPE_REF[index] = value
    def hasContent_(self):
        if (
            self.PORT_PROTOTYPE_REF or
            self.TARGET_DATA_PROTOTYPE_REF
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='AUTOSAR-VARIABLE-IREFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AUTOSAR-VARIABLE-IREFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AUTOSAR-VARIABLE-IREFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AUTOSAR-VARIABLE-IREFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AUTOSAR-VARIABLE-IREFType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='AUTOSAR-VARIABLE-IREFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PORT_PROTOTYPE_REF_ in self.PORT_PROTOTYPE_REF:
            namespaceprefix_ = self.PORT_PROTOTYPE_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.PORT_PROTOTYPE_REF_nsprefix_) else ''
            PORT_PROTOTYPE_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PORT-PROTOTYPE-REF', pretty_print=pretty_print)
        for TARGET_DATA_PROTOTYPE_REF_ in self.TARGET_DATA_PROTOTYPE_REF:
            namespaceprefix_ = self.TARGET_DATA_PROTOTYPE_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.TARGET_DATA_PROTOTYPE_REF_nsprefix_) else ''
            TARGET_DATA_PROTOTYPE_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TARGET-DATA-PROTOTYPE-REF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PORT-PROTOTYPE-REF':
            obj_ = PORT_PROTOTYPE_REFType.factory(parent_object_=self)
            obj_.build(child_)
            self.PORT_PROTOTYPE_REF.append(obj_)
            obj_.original_tagname_ = 'PORT-PROTOTYPE-REF'
        elif nodeName_ == 'TARGET-DATA-PROTOTYPE-REF':
            obj_ = TARGET_DATA_PROTOTYPE_REFType.factory(parent_object_=self)
            obj_.build(child_)
            self.TARGET_DATA_PROTOTYPE_REF.append(obj_)
            obj_.original_tagname_ = 'TARGET-DATA-PROTOTYPE-REF'
# end class AUTOSAR_VARIABLE_IREFType


class PORT_PROTOTYPE_REFType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DEST=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DEST = _cast(None, DEST)
        self.DEST_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PORT_PROTOTYPE_REFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PORT_PROTOTYPE_REFType.subclass:
            return PORT_PROTOTYPE_REFType.subclass(*args_, **kwargs_)
        else:
            return PORT_PROTOTYPE_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DEST(self):
        return self.DEST
    def set_DEST(self, DEST):
        self.DEST = DEST
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='PORT-PROTOTYPE-REFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PORT-PROTOTYPE-REFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PORT-PROTOTYPE-REFType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PORT-PROTOTYPE-REFType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PORT-PROTOTYPE-REFType'):
        if self.DEST is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            outfile.write(' DEST=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DEST), input_name='DEST')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='PORT-PROTOTYPE-REFType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DEST', node)
        if value is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            self.DEST = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PORT_PROTOTYPE_REFType


class TARGET_DATA_PROTOTYPE_REFType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DEST=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DEST = _cast(None, DEST)
        self.DEST_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TARGET_DATA_PROTOTYPE_REFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TARGET_DATA_PROTOTYPE_REFType.subclass:
            return TARGET_DATA_PROTOTYPE_REFType.subclass(*args_, **kwargs_)
        else:
            return TARGET_DATA_PROTOTYPE_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DEST(self):
        return self.DEST
    def set_DEST(self, DEST):
        self.DEST = DEST
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='TARGET-DATA-PROTOTYPE-REFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TARGET-DATA-PROTOTYPE-REFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TARGET-DATA-PROTOTYPE-REFType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TARGET-DATA-PROTOTYPE-REFType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TARGET-DATA-PROTOTYPE-REFType'):
        if self.DEST is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            outfile.write(' DEST=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DEST), input_name='DEST')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='TARGET-DATA-PROTOTYPE-REFType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DEST', node)
        if value is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            self.DEST = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TARGET_DATA_PROTOTYPE_REFType


class AR_PACKAGESType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, AR_PACKAGE=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if AR_PACKAGE is None:
            self.AR_PACKAGE = []
        else:
            self.AR_PACKAGE = AR_PACKAGE
        self.AR_PACKAGE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AR_PACKAGESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AR_PACKAGESType.subclass:
            return AR_PACKAGESType.subclass(*args_, **kwargs_)
        else:
            return AR_PACKAGESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AR_PACKAGE(self):
        return self.AR_PACKAGE
    def set_AR_PACKAGE(self, AR_PACKAGE):
        self.AR_PACKAGE = AR_PACKAGE
    def add_AR_PACKAGE(self, value):
        self.AR_PACKAGE.append(value)
    def insert_AR_PACKAGE_at(self, index, value):
        self.AR_PACKAGE.insert(index, value)
    def replace_AR_PACKAGE_at(self, index, value):
        self.AR_PACKAGE[index] = value
    def hasContent_(self):
        if (
            self.AR_PACKAGE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='AR-PACKAGESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AR-PACKAGESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AR-PACKAGESType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AR-PACKAGESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AR-PACKAGESType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='AR-PACKAGESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AR_PACKAGE_ in self.AR_PACKAGE:
            namespaceprefix_ = self.AR_PACKAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.AR_PACKAGE_nsprefix_) else ''
            AR_PACKAGE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AR-PACKAGE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AR-PACKAGE':
            obj_ = AR_PACKAGEType.factory(parent_object_=self)
            obj_.build(child_)
            self.AR_PACKAGE.append(obj_)
            obj_.original_tagname_ = 'AR-PACKAGE'
# end class AR_PACKAGESType


class AR_PACKAGEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UUID=None, SHORT_NAME=None, ELEMENTS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.UUID = _cast(None, UUID)
        self.UUID_nsprefix_ = None
        self.SHORT_NAME = SHORT_NAME
        self.SHORT_NAME_nsprefix_ = None
        if ELEMENTS is None:
            self.ELEMENTS = []
        else:
            self.ELEMENTS = ELEMENTS
        self.ELEMENTS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AR_PACKAGEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AR_PACKAGEType.subclass:
            return AR_PACKAGEType.subclass(*args_, **kwargs_)
        else:
            return AR_PACKAGEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SHORT_NAME(self):
        return self.SHORT_NAME
    def set_SHORT_NAME(self, SHORT_NAME):
        self.SHORT_NAME = SHORT_NAME
    def get_ELEMENTS(self):
        return self.ELEMENTS
    def set_ELEMENTS(self, ELEMENTS):
        self.ELEMENTS = ELEMENTS
    def add_ELEMENTS(self, value):
        self.ELEMENTS.append(value)
    def insert_ELEMENTS_at(self, index, value):
        self.ELEMENTS.insert(index, value)
    def replace_ELEMENTS_at(self, index, value):
        self.ELEMENTS[index] = value
    def get_UUID(self):
        return self.UUID
    def set_UUID(self, UUID):
        self.UUID = UUID
    def hasContent_(self):
        if (
            self.SHORT_NAME is not None or
            self.ELEMENTS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='AR-PACKAGEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AR-PACKAGEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AR-PACKAGEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AR-PACKAGEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AR-PACKAGEType'):
        if self.UUID is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            outfile.write(' UUID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UUID), input_name='UUID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='AR-PACKAGEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SHORT_NAME is not None:
            namespaceprefix_ = self.SHORT_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SHORT_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHORT-NAME>%s</%sSHORT-NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SHORT_NAME), input_name='SHORT-NAME')), namespaceprefix_ , eol_))
        for ELEMENTS_ in self.ELEMENTS:
            namespaceprefix_ = self.ELEMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.ELEMENTS_nsprefix_) else ''
            ELEMENTS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ELEMENTS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UUID', node)
        if value is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            self.UUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SHORT-NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SHORT_NAME')
            value_ = self.gds_validate_string(value_, node, 'SHORT_NAME')
            self.SHORT_NAME = value_
            self.SHORT_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'ELEMENTS':
            obj_ = ELEMENTSType.factory(parent_object_=self)
            obj_.build(child_)
            self.ELEMENTS.append(obj_)
            obj_.original_tagname_ = 'ELEMENTS'
# end class AR_PACKAGEType


class ELEMENTSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, APPLICATION_SW_COMPONENT_TYPE=None, SWC_IMPLEMENTATION=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if APPLICATION_SW_COMPONENT_TYPE is None:
            self.APPLICATION_SW_COMPONENT_TYPE = []
        else:
            self.APPLICATION_SW_COMPONENT_TYPE = APPLICATION_SW_COMPONENT_TYPE
        self.APPLICATION_SW_COMPONENT_TYPE_nsprefix_ = None
        if SWC_IMPLEMENTATION is None:
            self.SWC_IMPLEMENTATION = []
        else:
            self.SWC_IMPLEMENTATION = SWC_IMPLEMENTATION
        self.SWC_IMPLEMENTATION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ELEMENTSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ELEMENTSType.subclass:
            return ELEMENTSType.subclass(*args_, **kwargs_)
        else:
            return ELEMENTSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_APPLICATION_SW_COMPONENT_TYPE(self):
        return self.APPLICATION_SW_COMPONENT_TYPE
    def set_APPLICATION_SW_COMPONENT_TYPE(self, APPLICATION_SW_COMPONENT_TYPE):
        self.APPLICATION_SW_COMPONENT_TYPE = APPLICATION_SW_COMPONENT_TYPE
    def add_APPLICATION_SW_COMPONENT_TYPE(self, value):
        self.APPLICATION_SW_COMPONENT_TYPE.append(value)
    def insert_APPLICATION_SW_COMPONENT_TYPE_at(self, index, value):
        self.APPLICATION_SW_COMPONENT_TYPE.insert(index, value)
    def replace_APPLICATION_SW_COMPONENT_TYPE_at(self, index, value):
        self.APPLICATION_SW_COMPONENT_TYPE[index] = value
    def get_SWC_IMPLEMENTATION(self):
        return self.SWC_IMPLEMENTATION
    def set_SWC_IMPLEMENTATION(self, SWC_IMPLEMENTATION):
        self.SWC_IMPLEMENTATION = SWC_IMPLEMENTATION
    def add_SWC_IMPLEMENTATION(self, value):
        self.SWC_IMPLEMENTATION.append(value)
    def insert_SWC_IMPLEMENTATION_at(self, index, value):
        self.SWC_IMPLEMENTATION.insert(index, value)
    def replace_SWC_IMPLEMENTATION_at(self, index, value):
        self.SWC_IMPLEMENTATION[index] = value
    def hasContent_(self):
        if (
            self.APPLICATION_SW_COMPONENT_TYPE or
            self.SWC_IMPLEMENTATION
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='ELEMENTSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ELEMENTSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ELEMENTSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ELEMENTSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ELEMENTSType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='ELEMENTSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for APPLICATION_SW_COMPONENT_TYPE_ in self.APPLICATION_SW_COMPONENT_TYPE:
            namespaceprefix_ = self.APPLICATION_SW_COMPONENT_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.APPLICATION_SW_COMPONENT_TYPE_nsprefix_) else ''
            APPLICATION_SW_COMPONENT_TYPE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='APPLICATION-SW-COMPONENT-TYPE', pretty_print=pretty_print)
        for SWC_IMPLEMENTATION_ in self.SWC_IMPLEMENTATION:
            namespaceprefix_ = self.SWC_IMPLEMENTATION_nsprefix_ + ':' if (UseCapturedNS_ and self.SWC_IMPLEMENTATION_nsprefix_) else ''
            SWC_IMPLEMENTATION_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SWC-IMPLEMENTATION', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'APPLICATION-SW-COMPONENT-TYPE':
            obj_ = APPLICATION_SW_COMPONENT_TYPEType.factory(parent_object_=self)
            obj_.build(child_)
            self.APPLICATION_SW_COMPONENT_TYPE.append(obj_)
            obj_.original_tagname_ = 'APPLICATION-SW-COMPONENT-TYPE'
        elif nodeName_ == 'SWC-IMPLEMENTATION':
            obj_ = SWC_IMPLEMENTATIONType.factory(parent_object_=self)
            obj_.build(child_)
            self.SWC_IMPLEMENTATION.append(obj_)
            obj_.original_tagname_ = 'SWC-IMPLEMENTATION'
# end class ELEMENTSType


class APPLICATION_SW_COMPONENT_TYPEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UUID=None, SHORT_NAME=None, PORTS=None, INTERNAL_BEHAVIORS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.UUID = _cast(None, UUID)
        self.UUID_nsprefix_ = None
        self.SHORT_NAME = SHORT_NAME
        self.SHORT_NAME_nsprefix_ = None
        if PORTS is None:
            self.PORTS = []
        else:
            self.PORTS = PORTS
        self.PORTS_nsprefix_ = None
        if INTERNAL_BEHAVIORS is None:
            self.INTERNAL_BEHAVIORS = []
        else:
            self.INTERNAL_BEHAVIORS = INTERNAL_BEHAVIORS
        self.INTERNAL_BEHAVIORS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, APPLICATION_SW_COMPONENT_TYPEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if APPLICATION_SW_COMPONENT_TYPEType.subclass:
            return APPLICATION_SW_COMPONENT_TYPEType.subclass(*args_, **kwargs_)
        else:
            return APPLICATION_SW_COMPONENT_TYPEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SHORT_NAME(self):
        return self.SHORT_NAME
    def set_SHORT_NAME(self, SHORT_NAME):
        self.SHORT_NAME = SHORT_NAME
    def get_PORTS(self):
        return self.PORTS
    def set_PORTS(self, PORTS):
        self.PORTS = PORTS
    def add_PORTS(self, value):
        self.PORTS.append(value)
    def insert_PORTS_at(self, index, value):
        self.PORTS.insert(index, value)
    def replace_PORTS_at(self, index, value):
        self.PORTS[index] = value
    def get_INTERNAL_BEHAVIORS(self):
        return self.INTERNAL_BEHAVIORS
    def set_INTERNAL_BEHAVIORS(self, INTERNAL_BEHAVIORS):
        self.INTERNAL_BEHAVIORS = INTERNAL_BEHAVIORS
    def add_INTERNAL_BEHAVIORS(self, value):
        self.INTERNAL_BEHAVIORS.append(value)
    def insert_INTERNAL_BEHAVIORS_at(self, index, value):
        self.INTERNAL_BEHAVIORS.insert(index, value)
    def replace_INTERNAL_BEHAVIORS_at(self, index, value):
        self.INTERNAL_BEHAVIORS[index] = value
    def get_UUID(self):
        return self.UUID
    def set_UUID(self, UUID):
        self.UUID = UUID
    def hasContent_(self):
        if (
            self.SHORT_NAME is not None or
            self.PORTS or
            self.INTERNAL_BEHAVIORS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='APPLICATION-SW-COMPONENT-TYPEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('APPLICATION-SW-COMPONENT-TYPEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='APPLICATION-SW-COMPONENT-TYPEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='APPLICATION-SW-COMPONENT-TYPEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='APPLICATION-SW-COMPONENT-TYPEType'):
        if self.UUID is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            outfile.write(' UUID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UUID), input_name='UUID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='APPLICATION-SW-COMPONENT-TYPEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SHORT_NAME is not None:
            namespaceprefix_ = self.SHORT_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SHORT_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHORT-NAME>%s</%sSHORT-NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SHORT_NAME), input_name='SHORT-NAME')), namespaceprefix_ , eol_))
        for PORTS_ in self.PORTS:
            namespaceprefix_ = self.PORTS_nsprefix_ + ':' if (UseCapturedNS_ and self.PORTS_nsprefix_) else ''
            PORTS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PORTS', pretty_print=pretty_print)
        for INTERNAL_BEHAVIORS_ in self.INTERNAL_BEHAVIORS:
            namespaceprefix_ = self.INTERNAL_BEHAVIORS_nsprefix_ + ':' if (UseCapturedNS_ and self.INTERNAL_BEHAVIORS_nsprefix_) else ''
            INTERNAL_BEHAVIORS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='INTERNAL-BEHAVIORS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UUID', node)
        if value is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            self.UUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SHORT-NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SHORT_NAME')
            value_ = self.gds_validate_string(value_, node, 'SHORT_NAME')
            self.SHORT_NAME = value_
            self.SHORT_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PORTS':
            obj_ = PORTSType.factory(parent_object_=self)
            obj_.build(child_)
            self.PORTS.append(obj_)
            obj_.original_tagname_ = 'PORTS'
        elif nodeName_ == 'INTERNAL-BEHAVIORS':
            obj_ = INTERNAL_BEHAVIORSType.factory(parent_object_=self)
            obj_.build(child_)
            self.INTERNAL_BEHAVIORS.append(obj_)
            obj_.original_tagname_ = 'INTERNAL-BEHAVIORS'
# end class APPLICATION_SW_COMPONENT_TYPEType


class PORTSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, P_PORT_PROTOTYPE=None, R_PORT_PROTOTYPE=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if P_PORT_PROTOTYPE is None:
            self.P_PORT_PROTOTYPE = []
        else:
            self.P_PORT_PROTOTYPE = P_PORT_PROTOTYPE
        self.P_PORT_PROTOTYPE_nsprefix_ = None
        if R_PORT_PROTOTYPE is None:
            self.R_PORT_PROTOTYPE = []
        else:
            self.R_PORT_PROTOTYPE = R_PORT_PROTOTYPE
        self.R_PORT_PROTOTYPE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PORTSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PORTSType.subclass:
            return PORTSType.subclass(*args_, **kwargs_)
        else:
            return PORTSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_P_PORT_PROTOTYPE(self):
        return self.P_PORT_PROTOTYPE
    def set_P_PORT_PROTOTYPE(self, P_PORT_PROTOTYPE):
        self.P_PORT_PROTOTYPE = P_PORT_PROTOTYPE
    def add_P_PORT_PROTOTYPE(self, value):
        self.P_PORT_PROTOTYPE.append(value)
    def insert_P_PORT_PROTOTYPE_at(self, index, value):
        self.P_PORT_PROTOTYPE.insert(index, value)
    def replace_P_PORT_PROTOTYPE_at(self, index, value):
        self.P_PORT_PROTOTYPE[index] = value
    def get_R_PORT_PROTOTYPE(self):
        return self.R_PORT_PROTOTYPE
    def set_R_PORT_PROTOTYPE(self, R_PORT_PROTOTYPE):
        self.R_PORT_PROTOTYPE = R_PORT_PROTOTYPE
    def add_R_PORT_PROTOTYPE(self, value):
        self.R_PORT_PROTOTYPE.append(value)
    def insert_R_PORT_PROTOTYPE_at(self, index, value):
        self.R_PORT_PROTOTYPE.insert(index, value)
    def replace_R_PORT_PROTOTYPE_at(self, index, value):
        self.R_PORT_PROTOTYPE[index] = value
    def hasContent_(self):
        if (
            self.P_PORT_PROTOTYPE or
            self.R_PORT_PROTOTYPE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='PORTSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PORTSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PORTSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PORTSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PORTSType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='PORTSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for P_PORT_PROTOTYPE_ in self.P_PORT_PROTOTYPE:
            namespaceprefix_ = self.P_PORT_PROTOTYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.P_PORT_PROTOTYPE_nsprefix_) else ''
            P_PORT_PROTOTYPE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='P-PORT-PROTOTYPE', pretty_print=pretty_print)
        for R_PORT_PROTOTYPE_ in self.R_PORT_PROTOTYPE:
            namespaceprefix_ = self.R_PORT_PROTOTYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.R_PORT_PROTOTYPE_nsprefix_) else ''
            R_PORT_PROTOTYPE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='R-PORT-PROTOTYPE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'P-PORT-PROTOTYPE':
            obj_ = P_PORT_PROTOTYPEType.factory(parent_object_=self)
            obj_.build(child_)
            self.P_PORT_PROTOTYPE.append(obj_)
            obj_.original_tagname_ = 'P-PORT-PROTOTYPE'
        elif nodeName_ == 'R-PORT-PROTOTYPE':
            obj_ = R_PORT_PROTOTYPEType.factory(parent_object_=self)
            obj_.build(child_)
            self.R_PORT_PROTOTYPE.append(obj_)
            obj_.original_tagname_ = 'R-PORT-PROTOTYPE'
# end class PORTSType


class P_PORT_PROTOTYPEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UUID=None, SHORT_NAME=None, PROVIDED_COM_SPECS=None, PROVIDED_INTERFACE_TREF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.UUID = _cast(None, UUID)
        self.UUID_nsprefix_ = None
        self.SHORT_NAME = SHORT_NAME
        self.SHORT_NAME_nsprefix_ = None
        if PROVIDED_COM_SPECS is None:
            self.PROVIDED_COM_SPECS = []
        else:
            self.PROVIDED_COM_SPECS = PROVIDED_COM_SPECS
        self.PROVIDED_COM_SPECS_nsprefix_ = None
        if PROVIDED_INTERFACE_TREF is None:
            self.PROVIDED_INTERFACE_TREF = []
        else:
            self.PROVIDED_INTERFACE_TREF = PROVIDED_INTERFACE_TREF
        self.PROVIDED_INTERFACE_TREF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, P_PORT_PROTOTYPEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if P_PORT_PROTOTYPEType.subclass:
            return P_PORT_PROTOTYPEType.subclass(*args_, **kwargs_)
        else:
            return P_PORT_PROTOTYPEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SHORT_NAME(self):
        return self.SHORT_NAME
    def set_SHORT_NAME(self, SHORT_NAME):
        self.SHORT_NAME = SHORT_NAME
    def get_PROVIDED_COM_SPECS(self):
        return self.PROVIDED_COM_SPECS
    def set_PROVIDED_COM_SPECS(self, PROVIDED_COM_SPECS):
        self.PROVIDED_COM_SPECS = PROVIDED_COM_SPECS
    def add_PROVIDED_COM_SPECS(self, value):
        self.PROVIDED_COM_SPECS.append(value)
    def insert_PROVIDED_COM_SPECS_at(self, index, value):
        self.PROVIDED_COM_SPECS.insert(index, value)
    def replace_PROVIDED_COM_SPECS_at(self, index, value):
        self.PROVIDED_COM_SPECS[index] = value
    def get_PROVIDED_INTERFACE_TREF(self):
        return self.PROVIDED_INTERFACE_TREF
    def set_PROVIDED_INTERFACE_TREF(self, PROVIDED_INTERFACE_TREF):
        self.PROVIDED_INTERFACE_TREF = PROVIDED_INTERFACE_TREF
    def add_PROVIDED_INTERFACE_TREF(self, value):
        self.PROVIDED_INTERFACE_TREF.append(value)
    def insert_PROVIDED_INTERFACE_TREF_at(self, index, value):
        self.PROVIDED_INTERFACE_TREF.insert(index, value)
    def replace_PROVIDED_INTERFACE_TREF_at(self, index, value):
        self.PROVIDED_INTERFACE_TREF[index] = value
    def get_UUID(self):
        return self.UUID
    def set_UUID(self, UUID):
        self.UUID = UUID
    def hasContent_(self):
        if (
            self.SHORT_NAME is not None or
            self.PROVIDED_COM_SPECS or
            self.PROVIDED_INTERFACE_TREF
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='P-PORT-PROTOTYPEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('P-PORT-PROTOTYPEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='P-PORT-PROTOTYPEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='P-PORT-PROTOTYPEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='P-PORT-PROTOTYPEType'):
        if self.UUID is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            outfile.write(' UUID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UUID), input_name='UUID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='P-PORT-PROTOTYPEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SHORT_NAME is not None:
            namespaceprefix_ = self.SHORT_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SHORT_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHORT-NAME>%s</%sSHORT-NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SHORT_NAME), input_name='SHORT-NAME')), namespaceprefix_ , eol_))
        for PROVIDED_COM_SPECS_ in self.PROVIDED_COM_SPECS:
            namespaceprefix_ = self.PROVIDED_COM_SPECS_nsprefix_ + ':' if (UseCapturedNS_ and self.PROVIDED_COM_SPECS_nsprefix_) else ''
            PROVIDED_COM_SPECS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PROVIDED-COM-SPECS', pretty_print=pretty_print)
        for PROVIDED_INTERFACE_TREF_ in self.PROVIDED_INTERFACE_TREF:
            namespaceprefix_ = self.PROVIDED_INTERFACE_TREF_nsprefix_ + ':' if (UseCapturedNS_ and self.PROVIDED_INTERFACE_TREF_nsprefix_) else ''
            PROVIDED_INTERFACE_TREF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PROVIDED-INTERFACE-TREF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UUID', node)
        if value is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            self.UUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SHORT-NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SHORT_NAME')
            value_ = self.gds_validate_string(value_, node, 'SHORT_NAME')
            self.SHORT_NAME = value_
            self.SHORT_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PROVIDED-COM-SPECS':
            obj_ = PROVIDED_COM_SPECSType.factory(parent_object_=self)
            obj_.build(child_)
            self.PROVIDED_COM_SPECS.append(obj_)
            obj_.original_tagname_ = 'PROVIDED-COM-SPECS'
        elif nodeName_ == 'PROVIDED-INTERFACE-TREF':
            obj_ = PROVIDED_INTERFACE_TREFType.factory(parent_object_=self)
            obj_.build(child_)
            self.PROVIDED_INTERFACE_TREF.append(obj_)
            obj_.original_tagname_ = 'PROVIDED-INTERFACE-TREF'
# end class P_PORT_PROTOTYPEType


class PROVIDED_COM_SPECSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NONQUEUED_SENDER_COM_SPEC=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if NONQUEUED_SENDER_COM_SPEC is None:
            self.NONQUEUED_SENDER_COM_SPEC = []
        else:
            self.NONQUEUED_SENDER_COM_SPEC = NONQUEUED_SENDER_COM_SPEC
        self.NONQUEUED_SENDER_COM_SPEC_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PROVIDED_COM_SPECSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PROVIDED_COM_SPECSType.subclass:
            return PROVIDED_COM_SPECSType.subclass(*args_, **kwargs_)
        else:
            return PROVIDED_COM_SPECSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NONQUEUED_SENDER_COM_SPEC(self):
        return self.NONQUEUED_SENDER_COM_SPEC
    def set_NONQUEUED_SENDER_COM_SPEC(self, NONQUEUED_SENDER_COM_SPEC):
        self.NONQUEUED_SENDER_COM_SPEC = NONQUEUED_SENDER_COM_SPEC
    def add_NONQUEUED_SENDER_COM_SPEC(self, value):
        self.NONQUEUED_SENDER_COM_SPEC.append(value)
    def insert_NONQUEUED_SENDER_COM_SPEC_at(self, index, value):
        self.NONQUEUED_SENDER_COM_SPEC.insert(index, value)
    def replace_NONQUEUED_SENDER_COM_SPEC_at(self, index, value):
        self.NONQUEUED_SENDER_COM_SPEC[index] = value
    def hasContent_(self):
        if (
            self.NONQUEUED_SENDER_COM_SPEC
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='PROVIDED-COM-SPECSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PROVIDED-COM-SPECSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PROVIDED-COM-SPECSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PROVIDED-COM-SPECSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PROVIDED-COM-SPECSType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='PROVIDED-COM-SPECSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NONQUEUED_SENDER_COM_SPEC_ in self.NONQUEUED_SENDER_COM_SPEC:
            namespaceprefix_ = self.NONQUEUED_SENDER_COM_SPEC_nsprefix_ + ':' if (UseCapturedNS_ and self.NONQUEUED_SENDER_COM_SPEC_nsprefix_) else ''
            NONQUEUED_SENDER_COM_SPEC_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NONQUEUED-SENDER-COM-SPEC', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NONQUEUED-SENDER-COM-SPEC':
            obj_ = NONQUEUED_SENDER_COM_SPECType.factory(parent_object_=self)
            obj_.build(child_)
            self.NONQUEUED_SENDER_COM_SPEC.append(obj_)
            obj_.original_tagname_ = 'NONQUEUED-SENDER-COM-SPEC'
# end class PROVIDED_COM_SPECSType


class NONQUEUED_SENDER_COM_SPECType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATA_ELEMENT_REF=None, INIT_VALUE=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DATA_ELEMENT_REF is None:
            self.DATA_ELEMENT_REF = []
        else:
            self.DATA_ELEMENT_REF = DATA_ELEMENT_REF
        self.DATA_ELEMENT_REF_nsprefix_ = None
        if INIT_VALUE is None:
            self.INIT_VALUE = []
        else:
            self.INIT_VALUE = INIT_VALUE
        self.INIT_VALUE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NONQUEUED_SENDER_COM_SPECType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NONQUEUED_SENDER_COM_SPECType.subclass:
            return NONQUEUED_SENDER_COM_SPECType.subclass(*args_, **kwargs_)
        else:
            return NONQUEUED_SENDER_COM_SPECType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATA_ELEMENT_REF(self):
        return self.DATA_ELEMENT_REF
    def set_DATA_ELEMENT_REF(self, DATA_ELEMENT_REF):
        self.DATA_ELEMENT_REF = DATA_ELEMENT_REF
    def add_DATA_ELEMENT_REF(self, value):
        self.DATA_ELEMENT_REF.append(value)
    def insert_DATA_ELEMENT_REF_at(self, index, value):
        self.DATA_ELEMENT_REF.insert(index, value)
    def replace_DATA_ELEMENT_REF_at(self, index, value):
        self.DATA_ELEMENT_REF[index] = value
    def get_INIT_VALUE(self):
        return self.INIT_VALUE
    def set_INIT_VALUE(self, INIT_VALUE):
        self.INIT_VALUE = INIT_VALUE
    def add_INIT_VALUE(self, value):
        self.INIT_VALUE.append(value)
    def insert_INIT_VALUE_at(self, index, value):
        self.INIT_VALUE.insert(index, value)
    def replace_INIT_VALUE_at(self, index, value):
        self.INIT_VALUE[index] = value
    def hasContent_(self):
        if (
            self.DATA_ELEMENT_REF or
            self.INIT_VALUE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='NONQUEUED-SENDER-COM-SPECType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NONQUEUED-SENDER-COM-SPECType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NONQUEUED-SENDER-COM-SPECType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NONQUEUED-SENDER-COM-SPECType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NONQUEUED-SENDER-COM-SPECType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='NONQUEUED-SENDER-COM-SPECType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATA_ELEMENT_REF_ in self.DATA_ELEMENT_REF:
            namespaceprefix_ = self.DATA_ELEMENT_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.DATA_ELEMENT_REF_nsprefix_) else ''
            DATA_ELEMENT_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATA-ELEMENT-REF', pretty_print=pretty_print)
        for INIT_VALUE_ in self.INIT_VALUE:
            namespaceprefix_ = self.INIT_VALUE_nsprefix_ + ':' if (UseCapturedNS_ and self.INIT_VALUE_nsprefix_) else ''
            INIT_VALUE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='INIT-VALUE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATA-ELEMENT-REF':
            obj_ = DATA_ELEMENT_REF.factory(parent_object_=self)
            obj_.build(child_)
            self.DATA_ELEMENT_REF.append(obj_)
            obj_.original_tagname_ = 'DATA-ELEMENT-REF'
        elif nodeName_ == 'INIT-VALUE':
            obj_ = INIT_VALUE.factory(parent_object_=self)
            obj_.build(child_)
            self.INIT_VALUE.append(obj_)
            obj_.original_tagname_ = 'INIT-VALUE'
# end class NONQUEUED_SENDER_COM_SPECType


class PROVIDED_INTERFACE_TREFType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DEST=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DEST = _cast(None, DEST)
        self.DEST_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PROVIDED_INTERFACE_TREFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PROVIDED_INTERFACE_TREFType.subclass:
            return PROVIDED_INTERFACE_TREFType.subclass(*args_, **kwargs_)
        else:
            return PROVIDED_INTERFACE_TREFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DEST(self):
        return self.DEST
    def set_DEST(self, DEST):
        self.DEST = DEST
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='PROVIDED-INTERFACE-TREFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PROVIDED-INTERFACE-TREFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PROVIDED-INTERFACE-TREFType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PROVIDED-INTERFACE-TREFType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PROVIDED-INTERFACE-TREFType'):
        if self.DEST is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            outfile.write(' DEST=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DEST), input_name='DEST')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='PROVIDED-INTERFACE-TREFType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DEST', node)
        if value is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            self.DEST = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PROVIDED_INTERFACE_TREFType


class R_PORT_PROTOTYPEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UUID=None, SHORT_NAME=None, REQUIRED_COM_SPECS=None, REQUIRED_INTERFACE_TREF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.UUID = _cast(None, UUID)
        self.UUID_nsprefix_ = None
        self.SHORT_NAME = SHORT_NAME
        self.SHORT_NAME_nsprefix_ = None
        if REQUIRED_COM_SPECS is None:
            self.REQUIRED_COM_SPECS = []
        else:
            self.REQUIRED_COM_SPECS = REQUIRED_COM_SPECS
        self.REQUIRED_COM_SPECS_nsprefix_ = None
        if REQUIRED_INTERFACE_TREF is None:
            self.REQUIRED_INTERFACE_TREF = []
        else:
            self.REQUIRED_INTERFACE_TREF = REQUIRED_INTERFACE_TREF
        self.REQUIRED_INTERFACE_TREF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, R_PORT_PROTOTYPEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if R_PORT_PROTOTYPEType.subclass:
            return R_PORT_PROTOTYPEType.subclass(*args_, **kwargs_)
        else:
            return R_PORT_PROTOTYPEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SHORT_NAME(self):
        return self.SHORT_NAME
    def set_SHORT_NAME(self, SHORT_NAME):
        self.SHORT_NAME = SHORT_NAME
    def get_REQUIRED_COM_SPECS(self):
        return self.REQUIRED_COM_SPECS
    def set_REQUIRED_COM_SPECS(self, REQUIRED_COM_SPECS):
        self.REQUIRED_COM_SPECS = REQUIRED_COM_SPECS
    def add_REQUIRED_COM_SPECS(self, value):
        self.REQUIRED_COM_SPECS.append(value)
    def insert_REQUIRED_COM_SPECS_at(self, index, value):
        self.REQUIRED_COM_SPECS.insert(index, value)
    def replace_REQUIRED_COM_SPECS_at(self, index, value):
        self.REQUIRED_COM_SPECS[index] = value
    def get_REQUIRED_INTERFACE_TREF(self):
        return self.REQUIRED_INTERFACE_TREF
    def set_REQUIRED_INTERFACE_TREF(self, REQUIRED_INTERFACE_TREF):
        self.REQUIRED_INTERFACE_TREF = REQUIRED_INTERFACE_TREF
    def add_REQUIRED_INTERFACE_TREF(self, value):
        self.REQUIRED_INTERFACE_TREF.append(value)
    def insert_REQUIRED_INTERFACE_TREF_at(self, index, value):
        self.REQUIRED_INTERFACE_TREF.insert(index, value)
    def replace_REQUIRED_INTERFACE_TREF_at(self, index, value):
        self.REQUIRED_INTERFACE_TREF[index] = value
    def get_UUID(self):
        return self.UUID
    def set_UUID(self, UUID):
        self.UUID = UUID
    def hasContent_(self):
        if (
            self.SHORT_NAME is not None or
            self.REQUIRED_COM_SPECS or
            self.REQUIRED_INTERFACE_TREF
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='R-PORT-PROTOTYPEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('R-PORT-PROTOTYPEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='R-PORT-PROTOTYPEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='R-PORT-PROTOTYPEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='R-PORT-PROTOTYPEType'):
        if self.UUID is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            outfile.write(' UUID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UUID), input_name='UUID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='R-PORT-PROTOTYPEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SHORT_NAME is not None:
            namespaceprefix_ = self.SHORT_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SHORT_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHORT-NAME>%s</%sSHORT-NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SHORT_NAME), input_name='SHORT-NAME')), namespaceprefix_ , eol_))
        for REQUIRED_COM_SPECS_ in self.REQUIRED_COM_SPECS:
            namespaceprefix_ = self.REQUIRED_COM_SPECS_nsprefix_ + ':' if (UseCapturedNS_ and self.REQUIRED_COM_SPECS_nsprefix_) else ''
            REQUIRED_COM_SPECS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='REQUIRED-COM-SPECS', pretty_print=pretty_print)
        for REQUIRED_INTERFACE_TREF_ in self.REQUIRED_INTERFACE_TREF:
            namespaceprefix_ = self.REQUIRED_INTERFACE_TREF_nsprefix_ + ':' if (UseCapturedNS_ and self.REQUIRED_INTERFACE_TREF_nsprefix_) else ''
            REQUIRED_INTERFACE_TREF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='REQUIRED-INTERFACE-TREF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UUID', node)
        if value is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            self.UUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SHORT-NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SHORT_NAME')
            value_ = self.gds_validate_string(value_, node, 'SHORT_NAME')
            self.SHORT_NAME = value_
            self.SHORT_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'REQUIRED-COM-SPECS':
            obj_ = REQUIRED_COM_SPECSType.factory(parent_object_=self)
            obj_.build(child_)
            self.REQUIRED_COM_SPECS.append(obj_)
            obj_.original_tagname_ = 'REQUIRED-COM-SPECS'
        elif nodeName_ == 'REQUIRED-INTERFACE-TREF':
            obj_ = REQUIRED_INTERFACE_TREFType.factory(parent_object_=self)
            obj_.build(child_)
            self.REQUIRED_INTERFACE_TREF.append(obj_)
            obj_.original_tagname_ = 'REQUIRED-INTERFACE-TREF'
# end class R_PORT_PROTOTYPEType


class REQUIRED_COM_SPECSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NONQUEUED_RECEIVER_COM_SPEC=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if NONQUEUED_RECEIVER_COM_SPEC is None:
            self.NONQUEUED_RECEIVER_COM_SPEC = []
        else:
            self.NONQUEUED_RECEIVER_COM_SPEC = NONQUEUED_RECEIVER_COM_SPEC
        self.NONQUEUED_RECEIVER_COM_SPEC_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REQUIRED_COM_SPECSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REQUIRED_COM_SPECSType.subclass:
            return REQUIRED_COM_SPECSType.subclass(*args_, **kwargs_)
        else:
            return REQUIRED_COM_SPECSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NONQUEUED_RECEIVER_COM_SPEC(self):
        return self.NONQUEUED_RECEIVER_COM_SPEC
    def set_NONQUEUED_RECEIVER_COM_SPEC(self, NONQUEUED_RECEIVER_COM_SPEC):
        self.NONQUEUED_RECEIVER_COM_SPEC = NONQUEUED_RECEIVER_COM_SPEC
    def add_NONQUEUED_RECEIVER_COM_SPEC(self, value):
        self.NONQUEUED_RECEIVER_COM_SPEC.append(value)
    def insert_NONQUEUED_RECEIVER_COM_SPEC_at(self, index, value):
        self.NONQUEUED_RECEIVER_COM_SPEC.insert(index, value)
    def replace_NONQUEUED_RECEIVER_COM_SPEC_at(self, index, value):
        self.NONQUEUED_RECEIVER_COM_SPEC[index] = value
    def hasContent_(self):
        if (
            self.NONQUEUED_RECEIVER_COM_SPEC
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='REQUIRED-COM-SPECSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('REQUIRED-COM-SPECSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='REQUIRED-COM-SPECSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='REQUIRED-COM-SPECSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='REQUIRED-COM-SPECSType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='REQUIRED-COM-SPECSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NONQUEUED_RECEIVER_COM_SPEC_ in self.NONQUEUED_RECEIVER_COM_SPEC:
            namespaceprefix_ = self.NONQUEUED_RECEIVER_COM_SPEC_nsprefix_ + ':' if (UseCapturedNS_ and self.NONQUEUED_RECEIVER_COM_SPEC_nsprefix_) else ''
            NONQUEUED_RECEIVER_COM_SPEC_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NONQUEUED-RECEIVER-COM-SPEC', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NONQUEUED-RECEIVER-COM-SPEC':
            obj_ = NONQUEUED_RECEIVER_COM_SPECType.factory(parent_object_=self)
            obj_.build(child_)
            self.NONQUEUED_RECEIVER_COM_SPEC.append(obj_)
            obj_.original_tagname_ = 'NONQUEUED-RECEIVER-COM-SPEC'
# end class REQUIRED_COM_SPECSType


class NONQUEUED_RECEIVER_COM_SPECType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ALIVE_TIMEOUT=None, ENABLE_UPDATE=None, HANDLE_NEVER_RECEIVED=None, DATA_ELEMENT_REF=None, FILTER=None, INIT_VALUE=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ALIVE_TIMEOUT = ALIVE_TIMEOUT
        self.ALIVE_TIMEOUT_nsprefix_ = None
        self.ENABLE_UPDATE = ENABLE_UPDATE
        self.ENABLE_UPDATE_nsprefix_ = None
        self.HANDLE_NEVER_RECEIVED = HANDLE_NEVER_RECEIVED
        self.HANDLE_NEVER_RECEIVED_nsprefix_ = None
        if DATA_ELEMENT_REF is None:
            self.DATA_ELEMENT_REF = []
        else:
            self.DATA_ELEMENT_REF = DATA_ELEMENT_REF
        self.DATA_ELEMENT_REF_nsprefix_ = None
        if FILTER is None:
            self.FILTER = []
        else:
            self.FILTER = FILTER
        self.FILTER_nsprefix_ = None
        if INIT_VALUE is None:
            self.INIT_VALUE = []
        else:
            self.INIT_VALUE = INIT_VALUE
        self.INIT_VALUE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NONQUEUED_RECEIVER_COM_SPECType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NONQUEUED_RECEIVER_COM_SPECType.subclass:
            return NONQUEUED_RECEIVER_COM_SPECType.subclass(*args_, **kwargs_)
        else:
            return NONQUEUED_RECEIVER_COM_SPECType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ALIVE_TIMEOUT(self):
        return self.ALIVE_TIMEOUT
    def set_ALIVE_TIMEOUT(self, ALIVE_TIMEOUT):
        self.ALIVE_TIMEOUT = ALIVE_TIMEOUT
    def get_ENABLE_UPDATE(self):
        return self.ENABLE_UPDATE
    def set_ENABLE_UPDATE(self, ENABLE_UPDATE):
        self.ENABLE_UPDATE = ENABLE_UPDATE
    def get_HANDLE_NEVER_RECEIVED(self):
        return self.HANDLE_NEVER_RECEIVED
    def set_HANDLE_NEVER_RECEIVED(self, HANDLE_NEVER_RECEIVED):
        self.HANDLE_NEVER_RECEIVED = HANDLE_NEVER_RECEIVED
    def get_DATA_ELEMENT_REF(self):
        return self.DATA_ELEMENT_REF
    def set_DATA_ELEMENT_REF(self, DATA_ELEMENT_REF):
        self.DATA_ELEMENT_REF = DATA_ELEMENT_REF
    def add_DATA_ELEMENT_REF(self, value):
        self.DATA_ELEMENT_REF.append(value)
    def insert_DATA_ELEMENT_REF_at(self, index, value):
        self.DATA_ELEMENT_REF.insert(index, value)
    def replace_DATA_ELEMENT_REF_at(self, index, value):
        self.DATA_ELEMENT_REF[index] = value
    def get_FILTER(self):
        return self.FILTER
    def set_FILTER(self, FILTER):
        self.FILTER = FILTER
    def add_FILTER(self, value):
        self.FILTER.append(value)
    def insert_FILTER_at(self, index, value):
        self.FILTER.insert(index, value)
    def replace_FILTER_at(self, index, value):
        self.FILTER[index] = value
    def get_INIT_VALUE(self):
        return self.INIT_VALUE
    def set_INIT_VALUE(self, INIT_VALUE):
        self.INIT_VALUE = INIT_VALUE
    def add_INIT_VALUE(self, value):
        self.INIT_VALUE.append(value)
    def insert_INIT_VALUE_at(self, index, value):
        self.INIT_VALUE.insert(index, value)
    def replace_INIT_VALUE_at(self, index, value):
        self.INIT_VALUE[index] = value
    def hasContent_(self):
        if (
            self.ALIVE_TIMEOUT is not None or
            self.ENABLE_UPDATE is not None or
            self.HANDLE_NEVER_RECEIVED is not None or
            self.DATA_ELEMENT_REF or
            self.FILTER or
            self.INIT_VALUE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='NONQUEUED-RECEIVER-COM-SPECType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NONQUEUED-RECEIVER-COM-SPECType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NONQUEUED-RECEIVER-COM-SPECType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NONQUEUED-RECEIVER-COM-SPECType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NONQUEUED-RECEIVER-COM-SPECType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='NONQUEUED-RECEIVER-COM-SPECType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ALIVE_TIMEOUT is not None:
            namespaceprefix_ = self.ALIVE_TIMEOUT_nsprefix_ + ':' if (UseCapturedNS_ and self.ALIVE_TIMEOUT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sALIVE-TIMEOUT>%s</%sALIVE-TIMEOUT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ALIVE_TIMEOUT), input_name='ALIVE-TIMEOUT')), namespaceprefix_ , eol_))
        if self.ENABLE_UPDATE is not None:
            namespaceprefix_ = self.ENABLE_UPDATE_nsprefix_ + ':' if (UseCapturedNS_ and self.ENABLE_UPDATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sENABLE-UPDATE>%s</%sENABLE-UPDATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ENABLE_UPDATE), input_name='ENABLE-UPDATE')), namespaceprefix_ , eol_))
        if self.HANDLE_NEVER_RECEIVED is not None:
            namespaceprefix_ = self.HANDLE_NEVER_RECEIVED_nsprefix_ + ':' if (UseCapturedNS_ and self.HANDLE_NEVER_RECEIVED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHANDLE-NEVER-RECEIVED>%s</%sHANDLE-NEVER-RECEIVED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.HANDLE_NEVER_RECEIVED), input_name='HANDLE-NEVER-RECEIVED')), namespaceprefix_ , eol_))
        for DATA_ELEMENT_REF_ in self.DATA_ELEMENT_REF:
            namespaceprefix_ = self.DATA_ELEMENT_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.DATA_ELEMENT_REF_nsprefix_) else ''
            DATA_ELEMENT_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATA-ELEMENT-REF', pretty_print=pretty_print)
        for FILTER_ in self.FILTER:
            namespaceprefix_ = self.FILTER_nsprefix_ + ':' if (UseCapturedNS_ and self.FILTER_nsprefix_) else ''
            FILTER_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FILTER', pretty_print=pretty_print)
        for INIT_VALUE_ in self.INIT_VALUE:
            namespaceprefix_ = self.INIT_VALUE_nsprefix_ + ':' if (UseCapturedNS_ and self.INIT_VALUE_nsprefix_) else ''
            INIT_VALUE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='INIT-VALUE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ALIVE-TIMEOUT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ALIVE_TIMEOUT')
            value_ = self.gds_validate_string(value_, node, 'ALIVE_TIMEOUT')
            self.ALIVE_TIMEOUT = value_
            self.ALIVE_TIMEOUT_nsprefix_ = child_.prefix
        elif nodeName_ == 'ENABLE-UPDATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ENABLE_UPDATE')
            value_ = self.gds_validate_string(value_, node, 'ENABLE_UPDATE')
            self.ENABLE_UPDATE = value_
            self.ENABLE_UPDATE_nsprefix_ = child_.prefix
        elif nodeName_ == 'HANDLE-NEVER-RECEIVED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'HANDLE_NEVER_RECEIVED')
            value_ = self.gds_validate_string(value_, node, 'HANDLE_NEVER_RECEIVED')
            self.HANDLE_NEVER_RECEIVED = value_
            self.HANDLE_NEVER_RECEIVED_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATA-ELEMENT-REF':
            obj_ = DATA_ELEMENT_REF.factory(parent_object_=self)
            obj_.build(child_)
            self.DATA_ELEMENT_REF.append(obj_)
            obj_.original_tagname_ = 'DATA-ELEMENT-REF'
        elif nodeName_ == 'FILTER':
            obj_ = FILTERType.factory(parent_object_=self)
            obj_.build(child_)
            self.FILTER.append(obj_)
            obj_.original_tagname_ = 'FILTER'
        elif nodeName_ == 'INIT-VALUE':
            obj_ = INIT_VALUE.factory(parent_object_=self)
            obj_.build(child_)
            self.INIT_VALUE.append(obj_)
            obj_.original_tagname_ = 'INIT-VALUE'
# end class NONQUEUED_RECEIVER_COM_SPECType


class FILTERType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATA_FILTER_TYPE=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DATA_FILTER_TYPE = DATA_FILTER_TYPE
        self.DATA_FILTER_TYPE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FILTERType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FILTERType.subclass:
            return FILTERType.subclass(*args_, **kwargs_)
        else:
            return FILTERType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATA_FILTER_TYPE(self):
        return self.DATA_FILTER_TYPE
    def set_DATA_FILTER_TYPE(self, DATA_FILTER_TYPE):
        self.DATA_FILTER_TYPE = DATA_FILTER_TYPE
    def hasContent_(self):
        if (
            self.DATA_FILTER_TYPE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='FILTERType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FILTERType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FILTERType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FILTERType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FILTERType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='FILTERType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DATA_FILTER_TYPE is not None:
            namespaceprefix_ = self.DATA_FILTER_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.DATA_FILTER_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDATA-FILTER-TYPE>%s</%sDATA-FILTER-TYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DATA_FILTER_TYPE), input_name='DATA-FILTER-TYPE')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATA-FILTER-TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DATA_FILTER_TYPE')
            value_ = self.gds_validate_string(value_, node, 'DATA_FILTER_TYPE')
            self.DATA_FILTER_TYPE = value_
            self.DATA_FILTER_TYPE_nsprefix_ = child_.prefix
# end class FILTERType


class REQUIRED_INTERFACE_TREFType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DEST=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DEST = _cast(None, DEST)
        self.DEST_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REQUIRED_INTERFACE_TREFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REQUIRED_INTERFACE_TREFType.subclass:
            return REQUIRED_INTERFACE_TREFType.subclass(*args_, **kwargs_)
        else:
            return REQUIRED_INTERFACE_TREFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DEST(self):
        return self.DEST
    def set_DEST(self, DEST):
        self.DEST = DEST
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='REQUIRED-INTERFACE-TREFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('REQUIRED-INTERFACE-TREFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='REQUIRED-INTERFACE-TREFType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='REQUIRED-INTERFACE-TREFType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='REQUIRED-INTERFACE-TREFType'):
        if self.DEST is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            outfile.write(' DEST=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DEST), input_name='DEST')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='REQUIRED-INTERFACE-TREFType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DEST', node)
        if value is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            self.DEST = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class REQUIRED_INTERFACE_TREFType


class INTERNAL_BEHAVIORSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SWC_INTERNAL_BEHAVIOR=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SWC_INTERNAL_BEHAVIOR is None:
            self.SWC_INTERNAL_BEHAVIOR = []
        else:
            self.SWC_INTERNAL_BEHAVIOR = SWC_INTERNAL_BEHAVIOR
        self.SWC_INTERNAL_BEHAVIOR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INTERNAL_BEHAVIORSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INTERNAL_BEHAVIORSType.subclass:
            return INTERNAL_BEHAVIORSType.subclass(*args_, **kwargs_)
        else:
            return INTERNAL_BEHAVIORSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SWC_INTERNAL_BEHAVIOR(self):
        return self.SWC_INTERNAL_BEHAVIOR
    def set_SWC_INTERNAL_BEHAVIOR(self, SWC_INTERNAL_BEHAVIOR):
        self.SWC_INTERNAL_BEHAVIOR = SWC_INTERNAL_BEHAVIOR
    def add_SWC_INTERNAL_BEHAVIOR(self, value):
        self.SWC_INTERNAL_BEHAVIOR.append(value)
    def insert_SWC_INTERNAL_BEHAVIOR_at(self, index, value):
        self.SWC_INTERNAL_BEHAVIOR.insert(index, value)
    def replace_SWC_INTERNAL_BEHAVIOR_at(self, index, value):
        self.SWC_INTERNAL_BEHAVIOR[index] = value
    def hasContent_(self):
        if (
            self.SWC_INTERNAL_BEHAVIOR
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='INTERNAL-BEHAVIORSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INTERNAL-BEHAVIORSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='INTERNAL-BEHAVIORSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='INTERNAL-BEHAVIORSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='INTERNAL-BEHAVIORSType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='INTERNAL-BEHAVIORSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SWC_INTERNAL_BEHAVIOR_ in self.SWC_INTERNAL_BEHAVIOR:
            namespaceprefix_ = self.SWC_INTERNAL_BEHAVIOR_nsprefix_ + ':' if (UseCapturedNS_ and self.SWC_INTERNAL_BEHAVIOR_nsprefix_) else ''
            SWC_INTERNAL_BEHAVIOR_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SWC-INTERNAL-BEHAVIOR', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SWC-INTERNAL-BEHAVIOR':
            obj_ = SWC_INTERNAL_BEHAVIORType.factory(parent_object_=self)
            obj_.build(child_)
            self.SWC_INTERNAL_BEHAVIOR.append(obj_)
            obj_.original_tagname_ = 'SWC-INTERNAL-BEHAVIOR'
# end class INTERNAL_BEHAVIORSType


class SWC_INTERNAL_BEHAVIORType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UUID=None, SHORT_NAME=None, SUPPORTS_MULTIPLE_INSTANTIATION=None, EVENTS=None, RUNNABLES=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.UUID = _cast(None, UUID)
        self.UUID_nsprefix_ = None
        self.SHORT_NAME = SHORT_NAME
        self.SHORT_NAME_nsprefix_ = None
        self.SUPPORTS_MULTIPLE_INSTANTIATION = SUPPORTS_MULTIPLE_INSTANTIATION
        self.SUPPORTS_MULTIPLE_INSTANTIATION_nsprefix_ = None
        if EVENTS is None:
            self.EVENTS = []
        else:
            self.EVENTS = EVENTS
        self.EVENTS_nsprefix_ = None
        if RUNNABLES is None:
            self.RUNNABLES = []
        else:
            self.RUNNABLES = RUNNABLES
        self.RUNNABLES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SWC_INTERNAL_BEHAVIORType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SWC_INTERNAL_BEHAVIORType.subclass:
            return SWC_INTERNAL_BEHAVIORType.subclass(*args_, **kwargs_)
        else:
            return SWC_INTERNAL_BEHAVIORType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SHORT_NAME(self):
        return self.SHORT_NAME
    def set_SHORT_NAME(self, SHORT_NAME):
        self.SHORT_NAME = SHORT_NAME
    def get_SUPPORTS_MULTIPLE_INSTANTIATION(self):
        return self.SUPPORTS_MULTIPLE_INSTANTIATION
    def set_SUPPORTS_MULTIPLE_INSTANTIATION(self, SUPPORTS_MULTIPLE_INSTANTIATION):
        self.SUPPORTS_MULTIPLE_INSTANTIATION = SUPPORTS_MULTIPLE_INSTANTIATION
    def get_EVENTS(self):
        return self.EVENTS
    def set_EVENTS(self, EVENTS):
        self.EVENTS = EVENTS
    def add_EVENTS(self, value):
        self.EVENTS.append(value)
    def insert_EVENTS_at(self, index, value):
        self.EVENTS.insert(index, value)
    def replace_EVENTS_at(self, index, value):
        self.EVENTS[index] = value
    def get_RUNNABLES(self):
        return self.RUNNABLES
    def set_RUNNABLES(self, RUNNABLES):
        self.RUNNABLES = RUNNABLES
    def add_RUNNABLES(self, value):
        self.RUNNABLES.append(value)
    def insert_RUNNABLES_at(self, index, value):
        self.RUNNABLES.insert(index, value)
    def replace_RUNNABLES_at(self, index, value):
        self.RUNNABLES[index] = value
    def get_UUID(self):
        return self.UUID
    def set_UUID(self, UUID):
        self.UUID = UUID
    def hasContent_(self):
        if (
            self.SHORT_NAME is not None or
            self.SUPPORTS_MULTIPLE_INSTANTIATION is not None or
            self.EVENTS or
            self.RUNNABLES
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='SWC-INTERNAL-BEHAVIORType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SWC-INTERNAL-BEHAVIORType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SWC-INTERNAL-BEHAVIORType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SWC-INTERNAL-BEHAVIORType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SWC-INTERNAL-BEHAVIORType'):
        if self.UUID is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            outfile.write(' UUID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UUID), input_name='UUID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='SWC-INTERNAL-BEHAVIORType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SHORT_NAME is not None:
            namespaceprefix_ = self.SHORT_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SHORT_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHORT-NAME>%s</%sSHORT-NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SHORT_NAME), input_name='SHORT-NAME')), namespaceprefix_ , eol_))
        if self.SUPPORTS_MULTIPLE_INSTANTIATION is not None:
            namespaceprefix_ = self.SUPPORTS_MULTIPLE_INSTANTIATION_nsprefix_ + ':' if (UseCapturedNS_ and self.SUPPORTS_MULTIPLE_INSTANTIATION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSUPPORTS-MULTIPLE-INSTANTIATION>%s</%sSUPPORTS-MULTIPLE-INSTANTIATION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SUPPORTS_MULTIPLE_INSTANTIATION), input_name='SUPPORTS-MULTIPLE-INSTANTIATION')), namespaceprefix_ , eol_))
        for EVENTS_ in self.EVENTS:
            namespaceprefix_ = self.EVENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.EVENTS_nsprefix_) else ''
            EVENTS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EVENTS', pretty_print=pretty_print)
        for RUNNABLES_ in self.RUNNABLES:
            namespaceprefix_ = self.RUNNABLES_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNABLES_nsprefix_) else ''
            RUNNABLES_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RUNNABLES', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UUID', node)
        if value is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            self.UUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SHORT-NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SHORT_NAME')
            value_ = self.gds_validate_string(value_, node, 'SHORT_NAME')
            self.SHORT_NAME = value_
            self.SHORT_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'SUPPORTS-MULTIPLE-INSTANTIATION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SUPPORTS_MULTIPLE_INSTANTIATION')
            value_ = self.gds_validate_string(value_, node, 'SUPPORTS_MULTIPLE_INSTANTIATION')
            self.SUPPORTS_MULTIPLE_INSTANTIATION = value_
            self.SUPPORTS_MULTIPLE_INSTANTIATION_nsprefix_ = child_.prefix
        elif nodeName_ == 'EVENTS':
            obj_ = EVENTSType.factory(parent_object_=self)
            obj_.build(child_)
            self.EVENTS.append(obj_)
            obj_.original_tagname_ = 'EVENTS'
        elif nodeName_ == 'RUNNABLES':
            obj_ = RUNNABLESType.factory(parent_object_=self)
            obj_.build(child_)
            self.RUNNABLES.append(obj_)
            obj_.original_tagname_ = 'RUNNABLES'
# end class SWC_INTERNAL_BEHAVIORType


class EVENTSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, INIT_EVENT=None, TIMING_EVENT=None, DATA_RECEIVED_EVENT=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if INIT_EVENT is None:
            self.INIT_EVENT = []
        else:
            self.INIT_EVENT = INIT_EVENT
        self.INIT_EVENT_nsprefix_ = None
        if TIMING_EVENT is None:
            self.TIMING_EVENT = []
        else:
            self.TIMING_EVENT = TIMING_EVENT
        self.TIMING_EVENT_nsprefix_ = None
        if DATA_RECEIVED_EVENT is None:
            self.DATA_RECEIVED_EVENT = []
        else:
            self.DATA_RECEIVED_EVENT = DATA_RECEIVED_EVENT
        self.DATA_RECEIVED_EVENT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EVENTSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EVENTSType.subclass:
            return EVENTSType.subclass(*args_, **kwargs_)
        else:
            return EVENTSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_INIT_EVENT(self):
        return self.INIT_EVENT
    def set_INIT_EVENT(self, INIT_EVENT):
        self.INIT_EVENT = INIT_EVENT
    def add_INIT_EVENT(self, value):
        self.INIT_EVENT.append(value)
    def insert_INIT_EVENT_at(self, index, value):
        self.INIT_EVENT.insert(index, value)
    def replace_INIT_EVENT_at(self, index, value):
        self.INIT_EVENT[index] = value
    def get_TIMING_EVENT(self):
        return self.TIMING_EVENT
    def set_TIMING_EVENT(self, TIMING_EVENT):
        self.TIMING_EVENT = TIMING_EVENT
    def add_TIMING_EVENT(self, value):
        self.TIMING_EVENT.append(value)
    def insert_TIMING_EVENT_at(self, index, value):
        self.TIMING_EVENT.insert(index, value)
    def replace_TIMING_EVENT_at(self, index, value):
        self.TIMING_EVENT[index] = value
    def get_DATA_RECEIVED_EVENT(self):
        return self.DATA_RECEIVED_EVENT
    def set_DATA_RECEIVED_EVENT(self, DATA_RECEIVED_EVENT):
        self.DATA_RECEIVED_EVENT = DATA_RECEIVED_EVENT
    def add_DATA_RECEIVED_EVENT(self, value):
        self.DATA_RECEIVED_EVENT.append(value)
    def insert_DATA_RECEIVED_EVENT_at(self, index, value):
        self.DATA_RECEIVED_EVENT.insert(index, value)
    def replace_DATA_RECEIVED_EVENT_at(self, index, value):
        self.DATA_RECEIVED_EVENT[index] = value
    def hasContent_(self):
        if (
            self.INIT_EVENT or
            self.TIMING_EVENT or
            self.DATA_RECEIVED_EVENT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='EVENTSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EVENTSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EVENTSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EVENTSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EVENTSType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='EVENTSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for INIT_EVENT_ in self.INIT_EVENT:
            namespaceprefix_ = self.INIT_EVENT_nsprefix_ + ':' if (UseCapturedNS_ and self.INIT_EVENT_nsprefix_) else ''
            INIT_EVENT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='INIT-EVENT', pretty_print=pretty_print)
        for TIMING_EVENT_ in self.TIMING_EVENT:
            namespaceprefix_ = self.TIMING_EVENT_nsprefix_ + ':' if (UseCapturedNS_ and self.TIMING_EVENT_nsprefix_) else ''
            TIMING_EVENT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TIMING-EVENT', pretty_print=pretty_print)
        for DATA_RECEIVED_EVENT_ in self.DATA_RECEIVED_EVENT:
            namespaceprefix_ = self.DATA_RECEIVED_EVENT_nsprefix_ + ':' if (UseCapturedNS_ and self.DATA_RECEIVED_EVENT_nsprefix_) else ''
            DATA_RECEIVED_EVENT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATA-RECEIVED-EVENT', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INIT-EVENT':
            obj_ = INIT_EVENTType.factory(parent_object_=self)
            obj_.build(child_)
            self.INIT_EVENT.append(obj_)
            obj_.original_tagname_ = 'INIT-EVENT'
        elif nodeName_ == 'TIMING-EVENT':
            obj_ = TIMING_EVENTType.factory(parent_object_=self)
            obj_.build(child_)
            self.TIMING_EVENT.append(obj_)
            obj_.original_tagname_ = 'TIMING-EVENT'
        elif nodeName_ == 'DATA-RECEIVED-EVENT':
            obj_ = DATA_RECEIVED_EVENTType.factory(parent_object_=self)
            obj_.build(child_)
            self.DATA_RECEIVED_EVENT.append(obj_)
            obj_.original_tagname_ = 'DATA-RECEIVED-EVENT'
# end class EVENTSType


class INIT_EVENTType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UUID=None, SHORT_NAME=None, START_ON_EVENT_REF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.UUID = _cast(None, UUID)
        self.UUID_nsprefix_ = None
        self.SHORT_NAME = SHORT_NAME
        self.SHORT_NAME_nsprefix_ = None
        if START_ON_EVENT_REF is None:
            self.START_ON_EVENT_REF = []
        else:
            self.START_ON_EVENT_REF = START_ON_EVENT_REF
        self.START_ON_EVENT_REF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INIT_EVENTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INIT_EVENTType.subclass:
            return INIT_EVENTType.subclass(*args_, **kwargs_)
        else:
            return INIT_EVENTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SHORT_NAME(self):
        return self.SHORT_NAME
    def set_SHORT_NAME(self, SHORT_NAME):
        self.SHORT_NAME = SHORT_NAME
    def get_START_ON_EVENT_REF(self):
        return self.START_ON_EVENT_REF
    def set_START_ON_EVENT_REF(self, START_ON_EVENT_REF):
        self.START_ON_EVENT_REF = START_ON_EVENT_REF
    def add_START_ON_EVENT_REF(self, value):
        self.START_ON_EVENT_REF.append(value)
    def insert_START_ON_EVENT_REF_at(self, index, value):
        self.START_ON_EVENT_REF.insert(index, value)
    def replace_START_ON_EVENT_REF_at(self, index, value):
        self.START_ON_EVENT_REF[index] = value
    def get_UUID(self):
        return self.UUID
    def set_UUID(self, UUID):
        self.UUID = UUID
    def hasContent_(self):
        if (
            self.SHORT_NAME is not None or
            self.START_ON_EVENT_REF
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='INIT-EVENTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INIT-EVENTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='INIT-EVENTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='INIT-EVENTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='INIT-EVENTType'):
        if self.UUID is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            outfile.write(' UUID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UUID), input_name='UUID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='INIT-EVENTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SHORT_NAME is not None:
            namespaceprefix_ = self.SHORT_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SHORT_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHORT-NAME>%s</%sSHORT-NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SHORT_NAME), input_name='SHORT-NAME')), namespaceprefix_ , eol_))
        for START_ON_EVENT_REF_ in self.START_ON_EVENT_REF:
            namespaceprefix_ = self.START_ON_EVENT_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.START_ON_EVENT_REF_nsprefix_) else ''
            START_ON_EVENT_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='START-ON-EVENT-REF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UUID', node)
        if value is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            self.UUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SHORT-NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SHORT_NAME')
            value_ = self.gds_validate_string(value_, node, 'SHORT_NAME')
            self.SHORT_NAME = value_
            self.SHORT_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'START-ON-EVENT-REF':
            obj_ = START_ON_EVENT_REF.factory(parent_object_=self)
            obj_.build(child_)
            self.START_ON_EVENT_REF.append(obj_)
            obj_.original_tagname_ = 'START-ON-EVENT-REF'
# end class INIT_EVENTType


class TIMING_EVENTType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UUID=None, SHORT_NAME=None, PERIOD=None, START_ON_EVENT_REF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.UUID = _cast(None, UUID)
        self.UUID_nsprefix_ = None
        self.SHORT_NAME = SHORT_NAME
        self.SHORT_NAME_nsprefix_ = None
        self.PERIOD = PERIOD
        self.PERIOD_nsprefix_ = None
        if START_ON_EVENT_REF is None:
            self.START_ON_EVENT_REF = []
        else:
            self.START_ON_EVENT_REF = START_ON_EVENT_REF
        self.START_ON_EVENT_REF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TIMING_EVENTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TIMING_EVENTType.subclass:
            return TIMING_EVENTType.subclass(*args_, **kwargs_)
        else:
            return TIMING_EVENTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SHORT_NAME(self):
        return self.SHORT_NAME
    def set_SHORT_NAME(self, SHORT_NAME):
        self.SHORT_NAME = SHORT_NAME
    def get_PERIOD(self):
        return self.PERIOD
    def set_PERIOD(self, PERIOD):
        self.PERIOD = PERIOD
    def get_START_ON_EVENT_REF(self):
        return self.START_ON_EVENT_REF
    def set_START_ON_EVENT_REF(self, START_ON_EVENT_REF):
        self.START_ON_EVENT_REF = START_ON_EVENT_REF
    def add_START_ON_EVENT_REF(self, value):
        self.START_ON_EVENT_REF.append(value)
    def insert_START_ON_EVENT_REF_at(self, index, value):
        self.START_ON_EVENT_REF.insert(index, value)
    def replace_START_ON_EVENT_REF_at(self, index, value):
        self.START_ON_EVENT_REF[index] = value
    def get_UUID(self):
        return self.UUID
    def set_UUID(self, UUID):
        self.UUID = UUID
    def hasContent_(self):
        if (
            self.SHORT_NAME is not None or
            self.PERIOD is not None or
            self.START_ON_EVENT_REF
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='TIMING-EVENTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TIMING-EVENTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TIMING-EVENTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TIMING-EVENTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TIMING-EVENTType'):
        if self.UUID is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            outfile.write(' UUID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UUID), input_name='UUID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='TIMING-EVENTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SHORT_NAME is not None:
            namespaceprefix_ = self.SHORT_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SHORT_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHORT-NAME>%s</%sSHORT-NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SHORT_NAME), input_name='SHORT-NAME')), namespaceprefix_ , eol_))
        if self.PERIOD is not None:
            namespaceprefix_ = self.PERIOD_nsprefix_ + ':' if (UseCapturedNS_ and self.PERIOD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPERIOD>%s</%sPERIOD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PERIOD), input_name='PERIOD')), namespaceprefix_ , eol_))
        for START_ON_EVENT_REF_ in self.START_ON_EVENT_REF:
            namespaceprefix_ = self.START_ON_EVENT_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.START_ON_EVENT_REF_nsprefix_) else ''
            START_ON_EVENT_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='START-ON-EVENT-REF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UUID', node)
        if value is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            self.UUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SHORT-NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SHORT_NAME')
            value_ = self.gds_validate_string(value_, node, 'SHORT_NAME')
            self.SHORT_NAME = value_
            self.SHORT_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PERIOD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PERIOD')
            value_ = self.gds_validate_string(value_, node, 'PERIOD')
            self.PERIOD = value_
            self.PERIOD_nsprefix_ = child_.prefix
        elif nodeName_ == 'START-ON-EVENT-REF':
            obj_ = START_ON_EVENT_REF.factory(parent_object_=self)
            obj_.build(child_)
            self.START_ON_EVENT_REF.append(obj_)
            obj_.original_tagname_ = 'START-ON-EVENT-REF'
# end class TIMING_EVENTType


class DATA_RECEIVED_EVENTType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UUID=None, SHORT_NAME=None, START_ON_EVENT_REF=None, DATA_IREF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.UUID = _cast(None, UUID)
        self.UUID_nsprefix_ = None
        self.SHORT_NAME = SHORT_NAME
        self.SHORT_NAME_nsprefix_ = None
        if START_ON_EVENT_REF is None:
            self.START_ON_EVENT_REF = []
        else:
            self.START_ON_EVENT_REF = START_ON_EVENT_REF
        self.START_ON_EVENT_REF_nsprefix_ = None
        if DATA_IREF is None:
            self.DATA_IREF = []
        else:
            self.DATA_IREF = DATA_IREF
        self.DATA_IREF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATA_RECEIVED_EVENTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATA_RECEIVED_EVENTType.subclass:
            return DATA_RECEIVED_EVENTType.subclass(*args_, **kwargs_)
        else:
            return DATA_RECEIVED_EVENTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SHORT_NAME(self):
        return self.SHORT_NAME
    def set_SHORT_NAME(self, SHORT_NAME):
        self.SHORT_NAME = SHORT_NAME
    def get_START_ON_EVENT_REF(self):
        return self.START_ON_EVENT_REF
    def set_START_ON_EVENT_REF(self, START_ON_EVENT_REF):
        self.START_ON_EVENT_REF = START_ON_EVENT_REF
    def add_START_ON_EVENT_REF(self, value):
        self.START_ON_EVENT_REF.append(value)
    def insert_START_ON_EVENT_REF_at(self, index, value):
        self.START_ON_EVENT_REF.insert(index, value)
    def replace_START_ON_EVENT_REF_at(self, index, value):
        self.START_ON_EVENT_REF[index] = value
    def get_DATA_IREF(self):
        return self.DATA_IREF
    def set_DATA_IREF(self, DATA_IREF):
        self.DATA_IREF = DATA_IREF
    def add_DATA_IREF(self, value):
        self.DATA_IREF.append(value)
    def insert_DATA_IREF_at(self, index, value):
        self.DATA_IREF.insert(index, value)
    def replace_DATA_IREF_at(self, index, value):
        self.DATA_IREF[index] = value
    def get_UUID(self):
        return self.UUID
    def set_UUID(self, UUID):
        self.UUID = UUID
    def hasContent_(self):
        if (
            self.SHORT_NAME is not None or
            self.START_ON_EVENT_REF or
            self.DATA_IREF
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='DATA-RECEIVED-EVENTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATA-RECEIVED-EVENTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATA-RECEIVED-EVENTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATA-RECEIVED-EVENTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATA-RECEIVED-EVENTType'):
        if self.UUID is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            outfile.write(' UUID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UUID), input_name='UUID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='DATA-RECEIVED-EVENTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SHORT_NAME is not None:
            namespaceprefix_ = self.SHORT_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SHORT_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHORT-NAME>%s</%sSHORT-NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SHORT_NAME), input_name='SHORT-NAME')), namespaceprefix_ , eol_))
        for START_ON_EVENT_REF_ in self.START_ON_EVENT_REF:
            namespaceprefix_ = self.START_ON_EVENT_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.START_ON_EVENT_REF_nsprefix_) else ''
            START_ON_EVENT_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='START-ON-EVENT-REF', pretty_print=pretty_print)
        for DATA_IREF_ in self.DATA_IREF:
            namespaceprefix_ = self.DATA_IREF_nsprefix_ + ':' if (UseCapturedNS_ and self.DATA_IREF_nsprefix_) else ''
            DATA_IREF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATA-IREF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UUID', node)
        if value is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            self.UUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SHORT-NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SHORT_NAME')
            value_ = self.gds_validate_string(value_, node, 'SHORT_NAME')
            self.SHORT_NAME = value_
            self.SHORT_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'START-ON-EVENT-REF':
            obj_ = START_ON_EVENT_REF.factory(parent_object_=self)
            obj_.build(child_)
            self.START_ON_EVENT_REF.append(obj_)
            obj_.original_tagname_ = 'START-ON-EVENT-REF'
        elif nodeName_ == 'DATA-IREF':
            obj_ = DATA_IREFType.factory(parent_object_=self)
            obj_.build(child_)
            self.DATA_IREF.append(obj_)
            obj_.original_tagname_ = 'DATA-IREF'
# end class DATA_RECEIVED_EVENTType


class DATA_IREFType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CONTEXT_R_PORT_REF=None, TARGET_DATA_ELEMENT_REF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if CONTEXT_R_PORT_REF is None:
            self.CONTEXT_R_PORT_REF = []
        else:
            self.CONTEXT_R_PORT_REF = CONTEXT_R_PORT_REF
        self.CONTEXT_R_PORT_REF_nsprefix_ = None
        if TARGET_DATA_ELEMENT_REF is None:
            self.TARGET_DATA_ELEMENT_REF = []
        else:
            self.TARGET_DATA_ELEMENT_REF = TARGET_DATA_ELEMENT_REF
        self.TARGET_DATA_ELEMENT_REF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATA_IREFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATA_IREFType.subclass:
            return DATA_IREFType.subclass(*args_, **kwargs_)
        else:
            return DATA_IREFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CONTEXT_R_PORT_REF(self):
        return self.CONTEXT_R_PORT_REF
    def set_CONTEXT_R_PORT_REF(self, CONTEXT_R_PORT_REF):
        self.CONTEXT_R_PORT_REF = CONTEXT_R_PORT_REF
    def add_CONTEXT_R_PORT_REF(self, value):
        self.CONTEXT_R_PORT_REF.append(value)
    def insert_CONTEXT_R_PORT_REF_at(self, index, value):
        self.CONTEXT_R_PORT_REF.insert(index, value)
    def replace_CONTEXT_R_PORT_REF_at(self, index, value):
        self.CONTEXT_R_PORT_REF[index] = value
    def get_TARGET_DATA_ELEMENT_REF(self):
        return self.TARGET_DATA_ELEMENT_REF
    def set_TARGET_DATA_ELEMENT_REF(self, TARGET_DATA_ELEMENT_REF):
        self.TARGET_DATA_ELEMENT_REF = TARGET_DATA_ELEMENT_REF
    def add_TARGET_DATA_ELEMENT_REF(self, value):
        self.TARGET_DATA_ELEMENT_REF.append(value)
    def insert_TARGET_DATA_ELEMENT_REF_at(self, index, value):
        self.TARGET_DATA_ELEMENT_REF.insert(index, value)
    def replace_TARGET_DATA_ELEMENT_REF_at(self, index, value):
        self.TARGET_DATA_ELEMENT_REF[index] = value
    def hasContent_(self):
        if (
            self.CONTEXT_R_PORT_REF or
            self.TARGET_DATA_ELEMENT_REF
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='DATA-IREFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATA-IREFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATA-IREFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATA-IREFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATA-IREFType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='DATA-IREFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CONTEXT_R_PORT_REF_ in self.CONTEXT_R_PORT_REF:
            namespaceprefix_ = self.CONTEXT_R_PORT_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.CONTEXT_R_PORT_REF_nsprefix_) else ''
            CONTEXT_R_PORT_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CONTEXT-R-PORT-REF', pretty_print=pretty_print)
        for TARGET_DATA_ELEMENT_REF_ in self.TARGET_DATA_ELEMENT_REF:
            namespaceprefix_ = self.TARGET_DATA_ELEMENT_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.TARGET_DATA_ELEMENT_REF_nsprefix_) else ''
            TARGET_DATA_ELEMENT_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TARGET-DATA-ELEMENT-REF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CONTEXT-R-PORT-REF':
            obj_ = CONTEXT_R_PORT_REFType.factory(parent_object_=self)
            obj_.build(child_)
            self.CONTEXT_R_PORT_REF.append(obj_)
            obj_.original_tagname_ = 'CONTEXT-R-PORT-REF'
        elif nodeName_ == 'TARGET-DATA-ELEMENT-REF':
            obj_ = TARGET_DATA_ELEMENT_REFType.factory(parent_object_=self)
            obj_.build(child_)
            self.TARGET_DATA_ELEMENT_REF.append(obj_)
            obj_.original_tagname_ = 'TARGET-DATA-ELEMENT-REF'
# end class DATA_IREFType


class CONTEXT_R_PORT_REFType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DEST=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DEST = _cast(None, DEST)
        self.DEST_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CONTEXT_R_PORT_REFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CONTEXT_R_PORT_REFType.subclass:
            return CONTEXT_R_PORT_REFType.subclass(*args_, **kwargs_)
        else:
            return CONTEXT_R_PORT_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DEST(self):
        return self.DEST
    def set_DEST(self, DEST):
        self.DEST = DEST
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='CONTEXT-R-PORT-REFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CONTEXT-R-PORT-REFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CONTEXT-R-PORT-REFType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CONTEXT-R-PORT-REFType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CONTEXT-R-PORT-REFType'):
        if self.DEST is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            outfile.write(' DEST=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DEST), input_name='DEST')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='CONTEXT-R-PORT-REFType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DEST', node)
        if value is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            self.DEST = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CONTEXT_R_PORT_REFType


class TARGET_DATA_ELEMENT_REFType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DEST=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DEST = _cast(None, DEST)
        self.DEST_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TARGET_DATA_ELEMENT_REFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TARGET_DATA_ELEMENT_REFType.subclass:
            return TARGET_DATA_ELEMENT_REFType.subclass(*args_, **kwargs_)
        else:
            return TARGET_DATA_ELEMENT_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DEST(self):
        return self.DEST
    def set_DEST(self, DEST):
        self.DEST = DEST
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='TARGET-DATA-ELEMENT-REFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TARGET-DATA-ELEMENT-REFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TARGET-DATA-ELEMENT-REFType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TARGET-DATA-ELEMENT-REFType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TARGET-DATA-ELEMENT-REFType'):
        if self.DEST is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            outfile.write(' DEST=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DEST), input_name='DEST')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='TARGET-DATA-ELEMENT-REFType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DEST', node)
        if value is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            self.DEST = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TARGET_DATA_ELEMENT_REFType


class RUNNABLESType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, RUNNABLE_ENTITY=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if RUNNABLE_ENTITY is None:
            self.RUNNABLE_ENTITY = []
        else:
            self.RUNNABLE_ENTITY = RUNNABLE_ENTITY
        self.RUNNABLE_ENTITY_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RUNNABLESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RUNNABLESType.subclass:
            return RUNNABLESType.subclass(*args_, **kwargs_)
        else:
            return RUNNABLESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RUNNABLE_ENTITY(self):
        return self.RUNNABLE_ENTITY
    def set_RUNNABLE_ENTITY(self, RUNNABLE_ENTITY):
        self.RUNNABLE_ENTITY = RUNNABLE_ENTITY
    def add_RUNNABLE_ENTITY(self, value):
        self.RUNNABLE_ENTITY.append(value)
    def insert_RUNNABLE_ENTITY_at(self, index, value):
        self.RUNNABLE_ENTITY.insert(index, value)
    def replace_RUNNABLE_ENTITY_at(self, index, value):
        self.RUNNABLE_ENTITY[index] = value
    def hasContent_(self):
        if (
            self.RUNNABLE_ENTITY
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='RUNNABLESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RUNNABLESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RUNNABLESType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RUNNABLESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RUNNABLESType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='RUNNABLESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RUNNABLE_ENTITY_ in self.RUNNABLE_ENTITY:
            namespaceprefix_ = self.RUNNABLE_ENTITY_nsprefix_ + ':' if (UseCapturedNS_ and self.RUNNABLE_ENTITY_nsprefix_) else ''
            RUNNABLE_ENTITY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RUNNABLE-ENTITY', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RUNNABLE-ENTITY':
            obj_ = RUNNABLE_ENTITYType.factory(parent_object_=self)
            obj_.build(child_)
            self.RUNNABLE_ENTITY.append(obj_)
            obj_.original_tagname_ = 'RUNNABLE-ENTITY'
# end class RUNNABLESType


class RUNNABLE_ENTITYType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UUID=None, SHORT_NAME=None, MINIMUM_START_INTERVAL=None, SYMBOL=None, DATA_RECEIVE_POINT_BY_ARGUMENTS=None, DATA_SEND_POINTS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.UUID = _cast(None, UUID)
        self.UUID_nsprefix_ = None
        self.SHORT_NAME = SHORT_NAME
        self.SHORT_NAME_nsprefix_ = None
        self.MINIMUM_START_INTERVAL = MINIMUM_START_INTERVAL
        self.MINIMUM_START_INTERVAL_nsprefix_ = None
        self.SYMBOL = SYMBOL
        self.SYMBOL_nsprefix_ = None
        if DATA_RECEIVE_POINT_BY_ARGUMENTS is None:
            self.DATA_RECEIVE_POINT_BY_ARGUMENTS = []
        else:
            self.DATA_RECEIVE_POINT_BY_ARGUMENTS = DATA_RECEIVE_POINT_BY_ARGUMENTS
        self.DATA_RECEIVE_POINT_BY_ARGUMENTS_nsprefix_ = None
        if DATA_SEND_POINTS is None:
            self.DATA_SEND_POINTS = []
        else:
            self.DATA_SEND_POINTS = DATA_SEND_POINTS
        self.DATA_SEND_POINTS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RUNNABLE_ENTITYType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RUNNABLE_ENTITYType.subclass:
            return RUNNABLE_ENTITYType.subclass(*args_, **kwargs_)
        else:
            return RUNNABLE_ENTITYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SHORT_NAME(self):
        return self.SHORT_NAME
    def set_SHORT_NAME(self, SHORT_NAME):
        self.SHORT_NAME = SHORT_NAME
    def get_MINIMUM_START_INTERVAL(self):
        return self.MINIMUM_START_INTERVAL
    def set_MINIMUM_START_INTERVAL(self, MINIMUM_START_INTERVAL):
        self.MINIMUM_START_INTERVAL = MINIMUM_START_INTERVAL
    def get_SYMBOL(self):
        return self.SYMBOL
    def set_SYMBOL(self, SYMBOL):
        self.SYMBOL = SYMBOL
    def get_DATA_RECEIVE_POINT_BY_ARGUMENTS(self):
        return self.DATA_RECEIVE_POINT_BY_ARGUMENTS
    def set_DATA_RECEIVE_POINT_BY_ARGUMENTS(self, DATA_RECEIVE_POINT_BY_ARGUMENTS):
        self.DATA_RECEIVE_POINT_BY_ARGUMENTS = DATA_RECEIVE_POINT_BY_ARGUMENTS
    def add_DATA_RECEIVE_POINT_BY_ARGUMENTS(self, value):
        self.DATA_RECEIVE_POINT_BY_ARGUMENTS.append(value)
    def insert_DATA_RECEIVE_POINT_BY_ARGUMENTS_at(self, index, value):
        self.DATA_RECEIVE_POINT_BY_ARGUMENTS.insert(index, value)
    def replace_DATA_RECEIVE_POINT_BY_ARGUMENTS_at(self, index, value):
        self.DATA_RECEIVE_POINT_BY_ARGUMENTS[index] = value
    def get_DATA_SEND_POINTS(self):
        return self.DATA_SEND_POINTS
    def set_DATA_SEND_POINTS(self, DATA_SEND_POINTS):
        self.DATA_SEND_POINTS = DATA_SEND_POINTS
    def add_DATA_SEND_POINTS(self, value):
        self.DATA_SEND_POINTS.append(value)
    def insert_DATA_SEND_POINTS_at(self, index, value):
        self.DATA_SEND_POINTS.insert(index, value)
    def replace_DATA_SEND_POINTS_at(self, index, value):
        self.DATA_SEND_POINTS[index] = value
    def get_UUID(self):
        return self.UUID
    def set_UUID(self, UUID):
        self.UUID = UUID
    def hasContent_(self):
        if (
            self.SHORT_NAME is not None or
            self.MINIMUM_START_INTERVAL is not None or
            self.SYMBOL is not None or
            self.DATA_RECEIVE_POINT_BY_ARGUMENTS or
            self.DATA_SEND_POINTS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='RUNNABLE-ENTITYType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RUNNABLE-ENTITYType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RUNNABLE-ENTITYType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RUNNABLE-ENTITYType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RUNNABLE-ENTITYType'):
        if self.UUID is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            outfile.write(' UUID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UUID), input_name='UUID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='RUNNABLE-ENTITYType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SHORT_NAME is not None:
            namespaceprefix_ = self.SHORT_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SHORT_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHORT-NAME>%s</%sSHORT-NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SHORT_NAME), input_name='SHORT-NAME')), namespaceprefix_ , eol_))
        if self.MINIMUM_START_INTERVAL is not None:
            namespaceprefix_ = self.MINIMUM_START_INTERVAL_nsprefix_ + ':' if (UseCapturedNS_ and self.MINIMUM_START_INTERVAL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMINIMUM-START-INTERVAL>%s</%sMINIMUM-START-INTERVAL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MINIMUM_START_INTERVAL), input_name='MINIMUM-START-INTERVAL')), namespaceprefix_ , eol_))
        if self.SYMBOL is not None:
            namespaceprefix_ = self.SYMBOL_nsprefix_ + ':' if (UseCapturedNS_ and self.SYMBOL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSYMBOL>%s</%sSYMBOL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SYMBOL), input_name='SYMBOL')), namespaceprefix_ , eol_))
        for DATA_RECEIVE_POINT_BY_ARGUMENTS_ in self.DATA_RECEIVE_POINT_BY_ARGUMENTS:
            namespaceprefix_ = self.DATA_RECEIVE_POINT_BY_ARGUMENTS_nsprefix_ + ':' if (UseCapturedNS_ and self.DATA_RECEIVE_POINT_BY_ARGUMENTS_nsprefix_) else ''
            DATA_RECEIVE_POINT_BY_ARGUMENTS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATA-RECEIVE-POINT-BY-ARGUMENTS', pretty_print=pretty_print)
        for DATA_SEND_POINTS_ in self.DATA_SEND_POINTS:
            namespaceprefix_ = self.DATA_SEND_POINTS_nsprefix_ + ':' if (UseCapturedNS_ and self.DATA_SEND_POINTS_nsprefix_) else ''
            DATA_SEND_POINTS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATA-SEND-POINTS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UUID', node)
        if value is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            self.UUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SHORT-NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SHORT_NAME')
            value_ = self.gds_validate_string(value_, node, 'SHORT_NAME')
            self.SHORT_NAME = value_
            self.SHORT_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'MINIMUM-START-INTERVAL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MINIMUM_START_INTERVAL')
            value_ = self.gds_validate_string(value_, node, 'MINIMUM_START_INTERVAL')
            self.MINIMUM_START_INTERVAL = value_
            self.MINIMUM_START_INTERVAL_nsprefix_ = child_.prefix
        elif nodeName_ == 'SYMBOL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SYMBOL')
            value_ = self.gds_validate_string(value_, node, 'SYMBOL')
            self.SYMBOL = value_
            self.SYMBOL_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATA-RECEIVE-POINT-BY-ARGUMENTS':
            obj_ = DATA_RECEIVE_POINT_BY_ARGUMENTSType.factory(parent_object_=self)
            obj_.build(child_)
            self.DATA_RECEIVE_POINT_BY_ARGUMENTS.append(obj_)
            obj_.original_tagname_ = 'DATA-RECEIVE-POINT-BY-ARGUMENTS'
        elif nodeName_ == 'DATA-SEND-POINTS':
            obj_ = DATA_SEND_POINTSType.factory(parent_object_=self)
            obj_.build(child_)
            self.DATA_SEND_POINTS.append(obj_)
            obj_.original_tagname_ = 'DATA-SEND-POINTS'
# end class RUNNABLE_ENTITYType


class DATA_RECEIVE_POINT_BY_ARGUMENTSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VARIABLE_ACCESS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if VARIABLE_ACCESS is None:
            self.VARIABLE_ACCESS = []
        else:
            self.VARIABLE_ACCESS = VARIABLE_ACCESS
        self.VARIABLE_ACCESS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATA_RECEIVE_POINT_BY_ARGUMENTSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATA_RECEIVE_POINT_BY_ARGUMENTSType.subclass:
            return DATA_RECEIVE_POINT_BY_ARGUMENTSType.subclass(*args_, **kwargs_)
        else:
            return DATA_RECEIVE_POINT_BY_ARGUMENTSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VARIABLE_ACCESS(self):
        return self.VARIABLE_ACCESS
    def set_VARIABLE_ACCESS(self, VARIABLE_ACCESS):
        self.VARIABLE_ACCESS = VARIABLE_ACCESS
    def add_VARIABLE_ACCESS(self, value):
        self.VARIABLE_ACCESS.append(value)
    def insert_VARIABLE_ACCESS_at(self, index, value):
        self.VARIABLE_ACCESS.insert(index, value)
    def replace_VARIABLE_ACCESS_at(self, index, value):
        self.VARIABLE_ACCESS[index] = value
    def hasContent_(self):
        if (
            self.VARIABLE_ACCESS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='DATA-RECEIVE-POINT-BY-ARGUMENTSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATA-RECEIVE-POINT-BY-ARGUMENTSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATA-RECEIVE-POINT-BY-ARGUMENTSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATA-RECEIVE-POINT-BY-ARGUMENTSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATA-RECEIVE-POINT-BY-ARGUMENTSType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='DATA-RECEIVE-POINT-BY-ARGUMENTSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VARIABLE_ACCESS_ in self.VARIABLE_ACCESS:
            namespaceprefix_ = self.VARIABLE_ACCESS_nsprefix_ + ':' if (UseCapturedNS_ and self.VARIABLE_ACCESS_nsprefix_) else ''
            VARIABLE_ACCESS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VARIABLE-ACCESS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VARIABLE-ACCESS':
            obj_ = VARIABLE_ACCESS.factory(parent_object_=self)
            obj_.build(child_)
            self.VARIABLE_ACCESS.append(obj_)
            obj_.original_tagname_ = 'VARIABLE-ACCESS'
# end class DATA_RECEIVE_POINT_BY_ARGUMENTSType


class DATA_SEND_POINTSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VARIABLE_ACCESS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if VARIABLE_ACCESS is None:
            self.VARIABLE_ACCESS = []
        else:
            self.VARIABLE_ACCESS = VARIABLE_ACCESS
        self.VARIABLE_ACCESS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATA_SEND_POINTSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATA_SEND_POINTSType.subclass:
            return DATA_SEND_POINTSType.subclass(*args_, **kwargs_)
        else:
            return DATA_SEND_POINTSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VARIABLE_ACCESS(self):
        return self.VARIABLE_ACCESS
    def set_VARIABLE_ACCESS(self, VARIABLE_ACCESS):
        self.VARIABLE_ACCESS = VARIABLE_ACCESS
    def add_VARIABLE_ACCESS(self, value):
        self.VARIABLE_ACCESS.append(value)
    def insert_VARIABLE_ACCESS_at(self, index, value):
        self.VARIABLE_ACCESS.insert(index, value)
    def replace_VARIABLE_ACCESS_at(self, index, value):
        self.VARIABLE_ACCESS[index] = value
    def hasContent_(self):
        if (
            self.VARIABLE_ACCESS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='DATA-SEND-POINTSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATA-SEND-POINTSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATA-SEND-POINTSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATA-SEND-POINTSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATA-SEND-POINTSType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='DATA-SEND-POINTSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VARIABLE_ACCESS_ in self.VARIABLE_ACCESS:
            namespaceprefix_ = self.VARIABLE_ACCESS_nsprefix_ + ':' if (UseCapturedNS_ and self.VARIABLE_ACCESS_nsprefix_) else ''
            VARIABLE_ACCESS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VARIABLE-ACCESS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VARIABLE-ACCESS':
            obj_ = VARIABLE_ACCESS.factory(parent_object_=self)
            obj_.build(child_)
            self.VARIABLE_ACCESS.append(obj_)
            obj_.original_tagname_ = 'VARIABLE-ACCESS'
# end class DATA_SEND_POINTSType


class SWC_IMPLEMENTATIONType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UUID=None, SHORT_NAME=None, BEHAVIOR_REF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.UUID = _cast(None, UUID)
        self.UUID_nsprefix_ = None
        self.SHORT_NAME = SHORT_NAME
        self.SHORT_NAME_nsprefix_ = None
        if BEHAVIOR_REF is None:
            self.BEHAVIOR_REF = []
        else:
            self.BEHAVIOR_REF = BEHAVIOR_REF
        self.BEHAVIOR_REF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SWC_IMPLEMENTATIONType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SWC_IMPLEMENTATIONType.subclass:
            return SWC_IMPLEMENTATIONType.subclass(*args_, **kwargs_)
        else:
            return SWC_IMPLEMENTATIONType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SHORT_NAME(self):
        return self.SHORT_NAME
    def set_SHORT_NAME(self, SHORT_NAME):
        self.SHORT_NAME = SHORT_NAME
    def get_BEHAVIOR_REF(self):
        return self.BEHAVIOR_REF
    def set_BEHAVIOR_REF(self, BEHAVIOR_REF):
        self.BEHAVIOR_REF = BEHAVIOR_REF
    def add_BEHAVIOR_REF(self, value):
        self.BEHAVIOR_REF.append(value)
    def insert_BEHAVIOR_REF_at(self, index, value):
        self.BEHAVIOR_REF.insert(index, value)
    def replace_BEHAVIOR_REF_at(self, index, value):
        self.BEHAVIOR_REF[index] = value
    def get_UUID(self):
        return self.UUID
    def set_UUID(self, UUID):
        self.UUID = UUID
    def hasContent_(self):
        if (
            self.SHORT_NAME is not None or
            self.BEHAVIOR_REF
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='SWC-IMPLEMENTATIONType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SWC-IMPLEMENTATIONType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SWC-IMPLEMENTATIONType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SWC-IMPLEMENTATIONType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SWC-IMPLEMENTATIONType'):
        if self.UUID is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            outfile.write(' UUID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UUID), input_name='UUID')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0" xmlns:None="http://autosar.org/schema/r4.0" ', name_='SWC-IMPLEMENTATIONType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SHORT_NAME is not None:
            namespaceprefix_ = self.SHORT_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SHORT_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSHORT-NAME>%s</%sSHORT-NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SHORT_NAME), input_name='SHORT-NAME')), namespaceprefix_ , eol_))
        for BEHAVIOR_REF_ in self.BEHAVIOR_REF:
            namespaceprefix_ = self.BEHAVIOR_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.BEHAVIOR_REF_nsprefix_) else ''
            BEHAVIOR_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BEHAVIOR-REF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UUID', node)
        if value is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            self.UUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SHORT-NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SHORT_NAME')
            value_ = self.gds_validate_string(value_, node, 'SHORT_NAME')
            self.SHORT_NAME = value_
            self.SHORT_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'BEHAVIOR-REF':
            obj_ = BEHAVIOR_REFType.factory(parent_object_=self)
            obj_.build(child_)
            self.BEHAVIOR_REF.append(obj_)
            obj_.original_tagname_ = 'BEHAVIOR-REF'
# end class SWC_IMPLEMENTATIONType


class BEHAVIOR_REFType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DEST=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DEST = _cast(None, DEST)
        self.DEST_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BEHAVIOR_REFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BEHAVIOR_REFType.subclass:
            return BEHAVIOR_REFType.subclass(*args_, **kwargs_)
        else:
            return BEHAVIOR_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DEST(self):
        return self.DEST
    def set_DEST(self, DEST):
        self.DEST = DEST
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='BEHAVIOR-REFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BEHAVIOR-REFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BEHAVIOR-REFType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BEHAVIOR-REFType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BEHAVIOR-REFType'):
        if self.DEST is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            outfile.write(' DEST=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DEST), input_name='DEST')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"', name_='BEHAVIOR-REFType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DEST', node)
        if value is not None and 'DEST' not in already_processed:
            already_processed.add('DEST')
            self.DEST = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BEHAVIOR_REFType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=True):
    global CapturedNsmap_
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DATA_ELEMENT_REF'
        rootClass = DATA_ELEMENT_REF
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DATA_ELEMENT_REF'
        rootClass = DATA_ELEMENT_REF
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DATA_ELEMENT_REF'
        rootClass = DATA_ELEMENT_REF
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:mstns="http://autosar.org/schema/r4.0"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DATA_ELEMENT_REF'
        rootClass = DATA_ELEMENT_REF
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from mySWC_api import *\n\n')
        sys.stdout.write('import mySWC_api as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj

def saveToFile(mainlist):
    df = pd.DataFrame(mainlist)
    #print(df)
    df.to_excel('mySWC.xls',sheet_name="mySWC",encoding='utf-8',index=False)

def myhandler(o):
    alllist = []
    # 处理P-Port
    for item in o.AR_PACKAGES[0].AR_PACKAGE[0].ELEMENTS[0].APPLICATION_SW_COMPONENT_TYPE[0].PORTS[0].P_PORT_PROTOTYPE:
        #print(" ")
        #print(item.SHORT_NAME)
        for attrif in item.get_PROVIDED_INTERFACE_TREF():
            #print(attr.valueOf_.split('/')[2])
            pass
        for attr in item.PROVIDED_COM_SPECS[0].get_NONQUEUED_SENDER_COM_SPEC():
            #print(attr.DATA_ELEMENT_REF[0].valueOf_.split('/')[3],"=",attr.INIT_VALUE[0].NUMERICAL_VALUE_SPECIFICATION[0].VALUE[0])
            tempdict = {}  # 需要放在循环体内容，否则append时候会被覆盖为最后一个值
            tempdict['PORTName'] = item.SHORT_NAME
            tempdict['Direction'] = 'send'
            tempdict['InterfaceName'] = attrif.valueOf_.split('/')[-1]
            tempdict['ElementName'] = attr.DATA_ELEMENT_REF[0].valueOf_.split('/')[-1]
            tempdict['InitValue'] = attr.INIT_VALUE[0].NUMERICAL_VALUE_SPECIFICATION[0].VALUE[0]
            alllist.append(tempdict)

    # 处理R-Port
    for item in o.AR_PACKAGES[0].AR_PACKAGE[0].ELEMENTS[0].APPLICATION_SW_COMPONENT_TYPE[0].PORTS[0].R_PORT_PROTOTYPE:
        #print(" ")
        #print(item.SHORT_NAME)
        for attrif in item.get_REQUIRED_INTERFACE_TREF():
            pass
            #print(attr.valueOf_.split('/')[2])
        for attr in item.REQUIRED_COM_SPECS[0].get_NONQUEUED_RECEIVER_COM_SPEC():
            tempdict = {}  # 需要放在循环体内容，否则append时候会被覆盖为最后一个值
            tempdict['PORTName'] = item.SHORT_NAME
            tempdict['Direction'] = 'receive'
            tempdict['InterfaceName'] = attrif.valueOf_.split('/')[-1]   # 取最后一个元素
            tempdict['ElementName'] = attr.DATA_ELEMENT_REF[0].valueOf_.split('/')[-1]  # 取最后一个元素
            tempdict['InitValue'] = attr.INIT_VALUE[0].NUMERICAL_VALUE_SPECIFICATION[0].VALUE[0]
            tempdict['ALIVE_TIMEOUT'] = attr.ALIVE_TIMEOUT
            tempdict['ENABLE_UPDATE'] = attr.ENABLE_UPDATE
            tempdict['HANDLE_NEVER_RECEIVED'] = attr.HANDLE_NEVER_RECEIVED
            #print(attr.DATA_ELEMENT_REF[0].valueOf_.split('/')[3],"=",attr.INIT_VALUE[0].NUMERICAL_VALUE_SPECIFICATION[0].VALUE[0])
            #print(attr.ALIVE_TIMEOUT,attr.ENABLE_UPDATE,attr.HANDLE_NEVER_RECEIVED)
            alllist.append(tempdict)
    #saveToFile(alllist)
    return(alllist)


def swcXMLgen(filename):
    swcObj = parse(filename)
    myhandler(swcObj)
    return(myhandler(swcObj))

def main():
    args = sys.argv[1:]
    if len(args) == 1:
        myrootObj = parse(args[0])
        myhandler(myrootObj)
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

__all__ = [
    "ACCESSED_VARIABLEType",
    "APPLICATION_SW_COMPONENT_TYPEType",
    "AR_PACKAGESType",
    "AR_PACKAGEType",
    "AUTOSAR",
    "AUTOSAR_VARIABLE_IREFType",
    "BEHAVIOR_REFType",
    "CONTEXT_R_PORT_REFType",
    "DATA_ELEMENT_REF",
    "DATA_IREFType",
    "DATA_RECEIVED_EVENTType",
    "DATA_RECEIVE_POINT_BY_ARGUMENTSType",
    "DATA_SEND_POINTSType",
    "ELEMENTSType",
    "EVENTSType",
    "FILTERType",
    "INIT_EVENTType",
    "INIT_VALUE",
    "INTERNAL_BEHAVIORSType",
    "NONQUEUED_RECEIVER_COM_SPECType",
    "NONQUEUED_SENDER_COM_SPECType",
    "NUMERICAL_VALUE_SPECIFICATIONType",
    "PORTSType",
    "PORT_PROTOTYPE_REFType",
    "PROVIDED_COM_SPECSType",
    "PROVIDED_INTERFACE_TREFType",
    "P_PORT_PROTOTYPEType",
    "REQUIRED_COM_SPECSType",
    "REQUIRED_INTERFACE_TREFType",
    "RUNNABLESType",
    "RUNNABLE_ENTITYType",
    "R_PORT_PROTOTYPEType",
    "START_ON_EVENT_REF",
    "SWC_IMPLEMENTATIONType",
    "SWC_INTERNAL_BEHAVIORType",
    "TARGET_DATA_ELEMENT_REFType",
    "TARGET_DATA_PROTOTYPE_REFType",
    "TIMING_EVENTType",
    "VARIABLE_ACCESS"
]

